PARSER_BEGIN( JavaCCParser )

package com.barassolutions;

import com.barassolutions.ClassDescriptor.SubType;
import com.barassolutions.util.Logger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;

/**
 * Parser generated by JavaCC. It parses a newOz program file, taking tokens from the scanner
 * (also generated by JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;

    /** Name of the file that is being parsed. */
    private String fileName;

    /**
     * Report a syntax error.
     *
     * @param message message identifying the error.
     * @param args related values.
     */
    private void reportParserError(String message, Object... args) {
      ArrayList<Object> arguments = new ArrayList<Object>();
      arguments.add(fileName);
      arguments.add(token.beginLine);
      arguments.addAll(Arrays.asList(args));

      errorHasOccurred = true;
      Logger.error("%s:%d: "+message, arguments.toArray());
    }

    /**
     * Recover from the parser error that occurred by skipping to
     * any of the specified tokens.
     *
     * Current error recovery mechanism is rather simple-minded and is
     * based on skipping all the tokens until a new line or an EOF is
     * encountered. This scheme can be enhanced by passing in the
     * FOLLOW-SET of the non-terminal at hand.
     *
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event
     * of a parser error.
     */
    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[ i ].length; j++) {
                expected.append("\n");
                expected.append("\t");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought", getToken( 1 ), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought", getToken(1), expected);
        }

        // Recover
        boolean loop = true;
        do {
            token = getNextToken();
            for (int i : skipTo) {
                if (token.kind == i) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }

    /**
     * Set the name of the file that is being parsed.
     *
     * @param fileName name of the file.
     */
    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     *
     * @return true or false.
     */
    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The newOz lexical grammar starts here       //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\b"|"\t"|"\n"|"\r"|"\f"}//|"\v"}

// Single-line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Multi-line comment -- ignored
SKIP: {"/*" : MULTI_COMMENT}
<MULTI_COMMENT>
SKIP : {"*/" : DEFAULT | < ~[] >}

// Reserved words
TOKEN : {
  < AT: "at" >
| < ATTR: "attr" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
//| < CHOICE: "choice" > //TODO What's this ?
| < CLASS: "class" >
//| < COLLECT: "collect" > //TODO What's this ?
//| < COND: "cond" > //TODO What's this ?
| < CONTINUE: "continue" >
| < DECLARE: "declare" >
| < DEF: "def" >
| < DEFPROC: "defproc" >
| < DEFLT: "default" >
//| < DEFINE: "define" >
//| < DIS: "dis" > //TODO What's dis ?
| < DO: "do" >
| < ELSE: "else" >
//| < ELSECASE: "elsecase" >
//| < ELSEOF: "elseof" >
| < EXPORT: "export" >
| < EXTENDS: "extends" >
//| < FAIL: "fail" > //TODO What's this ?
| < FALSE: "false" >
//| < FEAT: "feat" > //TODO What's this ?
| < FINALLY: "finally" >
| < FOR: "for" >
| < FROM: "from" >
| < FUNCTOR: "functor" >
| < IF: "if" >
| < IMPORT: "import" >
| < IN: "in" >
| < LAZY: "lazy" >
| < LOCK: "lock" >
| < MATCH: "match" >
| < METH: "meth" >
| < NIL: "nil" >
//| < NOT: "not" > //TODO What's this ?
//| < OF: "of" >
| < OR: "or" >
//| < PREPARE: "prepare" > //TODO What's this ?
| < PROP: "prop" >
| < RAISE: "raise" >
//| < REQUIRE: "require" > //TODO What's this ?
| < RETURN: "return" >
| < SKP: "skip" >
| < SUPER: "super" >
| < THIS: "this" >
| < THREAD: "thread" >
| < TRUE: "true" >
| < TRY: "try" >
| < UNIT: "unit" >
| < VAL: "val" >
| < VAR: "var" >
}

// Operators
TOKEN : {
  <ASSIGN: "=">
| <PLUSASS: "+=">
| <MINUSASS: "-=">
| <DEFINE: ":=">
| <EQUAL: "==">
| <NE: "\\=">
| <LT: "<">
| <GT: ">">
| <LE: "=<">
| <GE: ">=">
| <LBARROW: "<=">
| <IMPL: "=>">
//| <AND: "&"> //TODO DELETED
| <LAND: "&&">
//| <PIPE: "|"> //TODO DELETED
| <LOR: "||">
| <LNOT: "!">
| <LNOTNOT: "!!">
| <MINUS: "-">
| <PLUS: "+">
| <STAR: "*">
//| <STARSTAR: "**">
| <SLASH: "/">
| <INC: "++">
| <DEC: "--">
| <BACKSLASH: "\\">
| <MODULO: "%">
| <HASHTAG: "#">
| <UNDERSCORE: "_">
| <DOLLAR: "$">
| <APOSTROPHE: "'">
| <QUOTE: "\"">
| <LACCENT: "`">
| <RACCENT: "´">
| <HAT: "^">
| <BOX: "[]">
//| <TILDE: "~">
| <DEGREE: "°"> //TODO attention pas présent sur un clavier ISO ?
//| <COMMERCAT: "@">
//| <LARROW: "<-">
//| <RARROW: "->">
//| <FDASSIGN: "=:">
//| <FDNE: "\\=:">
//| <FDLT: "<:">
//| <FDLE: "=<:">
//| <FDGT: ">:">
//| <FDGE: ">=:">
| <COLCOL: "::">
//| <COLCOLCOL: ":::">
}

// Separators
TOKEN : {
 <COMMA: ",">
| <LBRACK: "[">
| <LCURLY: "{">
| <LPAREN: "(">
| <RBRACK: "]">
| <RCURLY: "}">
| <RPAREN: ")">
| <SEMI: ";">
| <COLON: ":">
| <DOT: ".">
| <DOTDOT: "..">
| <ELLIPSIS: "...">
}

// Identifiers & literals
TOKEN : {
  < VARIABLESTRICT: ((<UPPERCASE>(<ALPHANUM>)*) | "`"(<ESC> | <PSEUDO_CHAR> | ~["`","\\","\n","\r"])"`") >
| < VARIABLE: <LOWERCASE>(<ALPHANUM>)* >
| < ATOM: (<ATOMLISP> | "´" (<ESC>| <PSEUDO_CHAR> | ~["\\","\n","\r"]) "´") >
| < ATOMLISP: <APOSTROPHE> (<LOWERCASE>|<UPPERCASE>) (<ALPHANUM>)* >
//| < LABEL: (<VARIABLE>|<ATOM>|<BOOLEAN>|<UNIT>) >
| < STRING: "\"" (<ESC> | <PSEUDO_CHAR> | ~["\"","\\","\n","\r"])* "\"" >
| < CHARACTER: (<DEGREE>(<CHARCHAR> | <PSEUDO_CHAR>) | "'"<ALPHANUM>"'" )> //| <CHARINT> ) >
| < INT: (<DECINT> | <HEXINT> | <OCTINT> | <BININT>) >
| < FLOAT: (<DIGIT>)+ <DOT> (<DIGIT>)* (("e"|"E")("~")?(<DIGIT>)+)? >
//| < BOOLEAN: (<TRUE> | <FALSE>) >

| < #UPPERCASE: ["A"-"Z"] >
| < #LOWERCASE: ["a"-"z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
| < #CHARINT: (["0"-"9"]|["1"-"9"]["0"-"9"]|"1"["0"-"9"]["0"-"9"]|"2"["0"-"4"]["0"-"9"]|"25"["0"-"5"])> // [0-255]
| < #ALPHANUM: (<UPPERCASE> | <LOWERCASE> | <DIGIT> | <UNDERSCORE>) >
| < #DECINT: ("0" | (<NON_ZERO_DIGIT> (<DIGIT>)*)) >
| < #HEXINT: "0" ("x"|"X") (<HEXDIGIT>)+ >
| < #OCTINT: "0" (<OCTDIGIT>)+ >
| < #BININT: "0" ("b"|"B") (<BINDIGIT>)+ >
| < #OCTDIGIT: ["0"-"7"] >
| < #HEXDIGIT: (<DIGIT> | ["A"-"F"] | ["a"-"f"]) >
| < #BINDIGIT: ["0"-"1"] >

| < #ESCAPE_CHAR: ("a"|"b"|"f"|"n"|"r"|"t"|<BACKSLASH>|<APOSTROPHE>|<QUOTE>|<DEGREE>) >
| < #ESC: <BACKSLASH> <ESCAPE_CHAR> >
| < #CHARCHAR: ~["\\"] >
// In the classes of words <variable>, <atom>, <string>, and <character> we use pseudo-characters,
// which represent single characters in different notations.
| < #PSEUDO_CHAR: (<BACKSLASH><OCTDIGIT><OCTDIGIT><OCTDIGIT>) | (<BACKSLASH>("x"|"X")<HEXDIGIT><HEXDIGIT>) >
}

// For anything else, we return an ERROR token. Without this
// definition the TokenManager will throw an Error when a lexical
// error occurs, making it impossible to recover from it. So we
// define this ERROR token.
TOKEN:
{
 < ERROR: ~[] >
}

/////////////////////////////////////////////////////////
//       The newOz syntactic grammar starts here         //
/////////////////////////////////////////////////////////
// Constructed from http://mozart2.org/mozart-v1/doc-1.4.0/notation/node3.html#chapter.context-free

/**
 * Parse an interactive statement and construct an AST
 * for it. After constructing the Parser, this is its entry point.
 *
 * <pre>
 *   interStatement ::= {nestConStatement}+
 *                      | DECLARE inStatement EOF
 * </pre>
 *
 * @return an AST for an interStatement.
 */
InterStatement interStatement(): {
    int line = 0;
    InStatement statement = null;
    Statement aStatement = null;
    ArrayList<Statement> statements = new ArrayList<Statement>();
    InterStatement out = null;
}
{
    try {
        //LOOKAHEAD( <DECLARE> inStatement() )
        <DECLARE> { line = token.beginLine; Logger.debug("Found an interStatement"); }
        statement = inStatement()
        <EOF>
        { out = new InterStatement(line, statement); } //Declare block
      |
        //LOOKAHEAD( nestConStatement() )
        ( aStatement = nestConStatement()
        { statements.add(aStatement); Logger.debug("Found a stand-alone statement"); } //Stand-alone statements
        )+
        { out = new InterStatement(line, statements); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return out; }
}


/**
 * Parse a statement.
 *
 * <pre>
 *   statement ::= nestConStatement
 *                  | SKIP
 * </pre>
 *
 * @return an AST for a statement.
 */
private Statement statement(): {
    int line = 0;
    Statement statement = null;
    Expression expression = null;
}
{
    try {
        <SKP>
          { line = token.beginLine;
          statement = new SkipStatement(line); }
        |
          //LOOKAHEAD( nestConStatement() )
          {Logger.debug("Found a nestConStatement");}
          statement = nestConStatement()
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return statement; }
}

/**
 * Parse an expression.
 *
 * <pre>
 *   expression ::= nestConExpression
 *                  | nestDecAnonym
 *                  | DOLLAR
 *                  | term
 *                  | THIS
 *                  | inExpression
 * </pre>
 *
 * @return an AST for an expression.
 */
private Expression expression(): {
    int line = 0;
    Expression expression = null;
    {Logger.debug("Entering expression()");}
}
{
    try {
          LOOKAHEAD( <DOLLAR> expression() )
          <DOLLAR>
          { line = token.beginLine;
          expression = new AnonymExpression(line); }
        | LOOKAHEAD( inExpression() )
          {Logger.debug("Found an inExpression");}
          expression = inExpression()
        | LOOKAHEAD( <IF> | <MATCH> | <TRY> | <RAISE> | <THREAD> )
          {Logger.debug("Found a nestConExpression");}
          expression = nestConExpression()
        | LOOKAHEAD( term() )
          {Logger.debug("Found a term");}
          expression = term()
        | LOOKAHEAD( (<DEFPROC>|<DEF>|<FUNCTOR>|<CLASS>) <DOLLAR> )
          {Logger.debug("Found a nestDecAnonym()");}
          expression = nestDecAnonym()
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return expression; }
}

/**
 * Parse a parenthesized expression.
 *
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 *
 * @return an AST for a parExpression.
 */
private Expression parExpression(): {
    int line = 0;
    Expression expr = null;
    {Logger.debug("Entering parExpression()");}
}
{
    try {
        <LPAREN> { line =token.beginLine; } expr = expression() <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new ParExpression(line, expr); }
}

/**
 * Parse an tement, that is a/multiple statement/s included in a block.
 *
 * <pre>
 *   inStatement ::= LCURLY {declarationPart} {statement} RCURLY
 * </pre>
 *
 * @return an AST for an inStatement.
 */
private InStatement inStatement(): {
    int line = 0;
    Declaration aDecl = null;
    ArrayList<Declaration> decls = new ArrayList<Declaration>();
    Statement aStatement = null;
    ArrayList<Statement> statements = new ArrayList<Statement>();
    {Logger.debug("Entering inStatement()");}
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        ( //LOOKAHEAD( declarationPart() )
          { Logger.debug("Found a declarationPart"); }
          aDecl = declarationPart() { decls.add(aDecl); }
        )*
        ( //LOOKAHEAD( statement() )
          { Logger.debug("Found a statement"); }
          aStatement = statement() { statements.add(aStatement); }
        )*
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new InStatement(line, decls, statements);}//, expression); }
}

/**
 * Parse an inExpression, that is an expression included in a block.
 *
 * <pre>
 *   inExpression ::= LCURLY {declarationPart} {statement} [expression] RCURLY
 * </pre>
 *
 * Note that expression is actually mandatory :
 *   but we will give the user an error message during the analysis instead.
 * @return an AST for an inExpression.
 */
private InExpression inExpression(): {
    int line = 0;
    Declaration aDecl = null;
    ArrayList<Declaration> decls = new ArrayList<Declaration>();
    Statement statement = null;
    ArrayList<Statement> statements = new ArrayList<Statement>();
    Expression expression = null;
    {Logger.debug("Entering inExpression()");}
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        ( LOOKAHEAD( declarationPart() )
          { Logger.debug("Found a declarationPart in inExpression()"); }
          aDecl = declarationPart() { decls.add(aDecl); }
        )*
        ( LOOKAHEAD( <SKP> | nestConStatement() )
          { Logger.debug("Found a statement in inExpression()"); }
          statement = statement() { statements.add(statement); }
        )*
        [
          LOOKAHEAD( <DOLLAR> | inExpression() | nestConExpression() | term() | nestDecAnonym() | <LPAREN> term() <RPAREN> )
          { Logger.debug("Found the returned expression in inExpression()"); }
          expression = expression()
        ]
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new InExpression(line, decls, statements, expression); }
}

/**
 * Parse a nestable construct (statement).
 *
 * <pre>
 *   nestConStatement ::= assignmentStatement
 *                    | variable LPAREN [expression {COMMA expression}] RPAREN
 *                    | inStatement
 *                    | IF parExpression inStatement
 *                      {ELSE IF LPAREN expression RPAREN inStatement}
 *                      [ELSE inStatement]
 *                    | MATCH expression LCURLY
 *                      {CASE caseStatementClause}+
 *                      [ELSE inStatement]
 *                      RCURLY
 *                    | FOR LPAREN {loopDec}+ RPAREN inStatement
 *                    | TRY inStatement
 *                      [CATCH LCURLY
 *                      {CASE caseStatementClause}+
 *                      RCURLY]
 *                      [FINALLY inStatement]
 *                    | RAISE inExpression
 *                    | THREAD inStatement
 *                    | LOCK [LPAREN expression RPAREN] inStatement
 * </pre>
 *
 * @return an AST for a nestConStatement.
 */
private Statement nestConStatement(): {
    int line = 0;
    Statement out = null;
    String name = null;
    InStatement statement = null;
    InStatement statement2 = null;
    Expression expression = null;
    Expression expression2 = null;
    ArrayList<Expression> args = new ArrayList<Expression>();
    ArrayList<Expression> conds = new ArrayList<Expression>();
    ArrayList<InStatement> consq = new ArrayList<InStatement>();
    boolean firstClausePassed = false;
    CaseStatementClause aClause = null;
    ArrayList<CaseStatementClause> clauses = new ArrayList<CaseStatementClause>();
    LoopDeclaration loopDec = null;
    ArrayList<LoopDeclaration> loopDecs = new ArrayList<LoopDeclaration>();
    {Logger.debug("Entering nestConStatement()");}
}
{
    try {
          LOOKAHEAD( <VARIABLE> <LPAREN> )
          <VARIABLE> { line = token.beginLine; name = token.image;
            Logger.debug("Found a CallProcedure to "+name+" at line "+line); }
          <LPAREN>
          [ LOOKAHEAD( expression() )
            expression2 = expression() { args.add(expression2); }
            (
              LOOKAHEAD( <COMMA> expression() )
              <COMMA> expression2 = expression() { args.add(expression2); }
            )*
          ]
          <RPAREN>
          { out = new CallProcedure(line, name, args); }
        | LOOKAHEAD( <LCURLY> )
          statement2 = inStatement()
          { out = statement2; }
        | LOOKAHEAD( <IF> )
          <IF> { line = token.beginLine; }
          expression = parExpression()
          statement2 = inStatement()
          { conds.add(expression); consq.add(statement2); }
          ( LOOKAHEAD( <ELSE> <IF> )
            <ELSE> <IF> expression = parExpression() statement2 = inStatement()
            { conds.add(expression); consq.add(statement2); }
          )*
          [
            LOOKAHEAD( <ELSE> )
            <ELSE> statement2 = inStatement()
            { consq.add(statement2); }
          ]
          { out = new ConditionalStatement(line, conds, consq); }
        | LOOKAHEAD( <MATCH> )
          <MATCH> { line = token.beginLine; }
          expression = expression() <LCURLY>
          (
            LOOKAHEAD( <CASE> )
            <CASE> aClause = caseStatementClause(firstClausePassed) { firstClausePassed = true; clauses.add(aClause); }
          )+
          [
            LOOKAHEAD( <ELSE> )
            <ELSE> statement2 = inStatement() ]
          { out = new CaseStructStatement(line, expression, clauses, statement2); }
          <RCURLY>
        | LOOKAHEAD( <FOR> )
          <FOR> { line = token.beginLine; }
          <LPAREN>
          (
            LOOKAHEAD( loopDeclaration() )
            loopDec = loopDeclaration()
            { loopDecs.add(loopDec); }
          )+
          <RPAREN> statement2 = inStatement()
          { out = new LoopStructure(line, loopDecs, statement2); }
        | LOOKAHEAD( <TRY> )
          <TRY> { line = token.beginLine; }
          statement = inStatement()
          [
            LOOKAHEAD( <CATCH> <LCURLY> )
            <CATCH> <LCURLY>
            (
              LOOKAHEAD( <CASE> caseStatementClause() )
              <CASE> aClause = caseStatementClause(firstClausePassed) { firstClausePassed = true; clauses.add(aClause); }
            )+
            <RCURLY>
          ]
          [
            LOOKAHEAD( <FINALLY> )
            <FINALLY> statement2 = inStatement()
          ]
          { out = new TryStructure(line, statement, clauses, statement2); }
        | LOOKAHEAD( <RAISE> )
          <RAISE> { line = token.beginLine; }
          expression = inExpression()
          { out = new RaiseStructure(line, expression); }
        | LOOKAHEAD( <THREAD> )
          <THREAD> { line = token.beginLine; }
          statement2 = inStatement()
          { out = new ThreadStructure(line, statement2); }
        | LOOKAHEAD( <LOCK> )
          <LOCK> { line = token.beginLine; }
          [
            LOOKAHEAD( <LPAREN> expression() <RPAREN> )
            <LPAREN> expression = expression() <RPAREN>
          ]
          statement2 = inStatement()
          { out = new LockStructure(line, expression, statement2); }
        | LOOKAHEAD( <VARIABLE> <ASSIGN> )
          { Logger.debug("Found an assignmentStatement()"); }
          out = assignmentStatement()
              }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable construct (expression).
 *
 * <pre>
 *   nestConExpression ::=
 *                      IF parExpression inExpression
 *                      {ELSE IF LPAREN expression RPAREN inExpression}
 *                      [ELSE inExpression]
 *                    | MATCH expression LCURLY
 *                      {CASE caseExpressionClause}+
 *                      [ELSE inExpression]
 *                      RCURLY
 *                    | TRY inExpression
 *                      [CATCH LCURLY
 *                      {CASE caseExpressionClause}+
 *                      RCURLY]
 *                      [FINALLY inStatement]
 *                    | RAISE inExpression
 *                    | THREAD inExpression
 * </pre>
 *
 * @return an AST for a nestConExpression.
 */
private Expression nestConExpression(): {
    int line = 0;
    Expression out = null;
    String name = null;
    InStatement statement = null;
    Expression expression = null;
    InExpression expression2 = null;
    ArrayList<Expression> args = new ArrayList<Expression>();
    ArrayList<Expression> conds = new ArrayList<Expression>();
    ArrayList<InExpression> consq = new ArrayList<InExpression>();
    boolean firstClausePassed = false;
    CaseExpressionClause aClause = null;
    ArrayList<CaseExpressionClause> clauses = new ArrayList<CaseExpressionClause>();
}
{
    try {
          LOOKAHEAD( <IF> parExpression() inExpression() )
            <IF> { line = token.beginLine;
            Logger.debug("Found if expression"); }
            expression = parExpression()
            expression2 = inExpression()
            { conds.add(expression); consq.add(expression2); }
            ( LOOKAHEAD( <ELSE> <IF> )
              { Logger.debug("Found else if block"); }
              <ELSE> <IF> expression = parExpression() expression2 = inExpression()
              { conds.add(expression); consq.add(expression2); }
            )*
            { Logger.debug("Done with elseif blocks"); }
            [
              LOOKAHEAD( <ELSE> )
              { Logger.debug("Found else block"); }
              <ELSE> expression2 = inExpression()
              { consq.add(expression2); }
            ]
            { out = new ConditionalExpression(line, conds, consq); }
        | LOOKAHEAD( <MATCH> )
            <MATCH> { line = token.beginLine; }
          expression = expression() <LCURLY>
          (
            LOOKAHEAD( <CASE> )
            <CASE> aClause = caseExpressionClause(firstClausePassed) { firstClausePassed = true; clauses.add(aClause); }
          )+
          [
            LOOKAHEAD( <ELSE> )
            <ELSE> expression2 = inExpression()
          ]
          { out = new CaseStructExpression(line, expression, clauses, expression2); }
          <RCURLY>
        | LOOKAHEAD( <TRY> )
          <TRY> { line = token.beginLine; }
          expression = inExpression()
          [
            LOOKAHEAD( <CATCH> <LCURLY> )
            <CATCH> <LCURLY>
            (
              LOOKAHEAD( <CASE> caseExpressionClause() )
              <CASE> aClause = caseExpressionClause(firstClausePassed) { firstClausePassed = true; clauses.add(aClause); }
            )+
            <RCURLY>
          ]
          [
            LOOKAHEAD( <FINALLY> inStatement() )
            <FINALLY> statement = inStatement()
          ]
          { out = new TryExpression(line, (InExpression) expression, clauses, statement); }
        | LOOKAHEAD( <RAISE> )
          <RAISE> { line = token.beginLine; }
          expression = inExpression()
          { out = new RaiseExpression(line, expression); }
        | LOOKAHEAD( <THREAD> )
          <THREAD> { line = token.beginLine; }
          expression = inExpression()
          { out = new ThreadExpression(line, (InExpression) expression); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable declaration (variables).
 *
 * <pre>
 *   nestDecVariable ::= DEFPROC variable LPAREN [pattern {COMMA pattern}] RPAREN inStatement
 *                 | DEF [LAZY] variable LPAREN [pattern {COMMA pattern}] RPAREN inExpression
 *                 | FUNCTOR [variable] {
 *                     (IMPORT importClause {COMMA importClause}+)
 *                     | (EXPORT exportClause {COMMA exportClause}+)
 *                   }
 *                   inStatement
 *                 | CLASS variableStrict {classDescriptor} LCURLY
 *                   {classElementDef} RCURLY
 * </pre>
 *
 * @return an AST for a nestDecVariable.
 */
private Declaration nestDecVariable(): {
    int line = 0;
    Declaration out = null;
    InStatement statement = null;
    InExpression expression = null;
    String name = null;
    boolean lazy = false;
    Pattern aPattern = null;
    ArrayList<Pattern> args = new ArrayList<Pattern>();
    ImportClause importClause = null;
    ArrayList<ImportClause> imports = new ArrayList<ImportClause>();
    ExportClause exportClause = null;
    ArrayList<ExportClause> exports = new ArrayList<ExportClause>();
    ClassDescriptor aDescriptor = null;
    ArrayList<ClassDescriptor> descriptors = new ArrayList<ClassDescriptor>();
    ClassElement classElement = null;
    ArrayList<MethodDef> methods = new ArrayList<MethodDef>();
    {Logger.debug("Entering nestDecVariable()");}
}
{
    try {
          LOOKAHEAD( <DEFPROC> <VARIABLE> <LPAREN> )
          { Logger.debug("Found a Procedure definition"); }
          <DEFPROC> { line = token.beginLine; }
          <VARIABLE> { name = token.image; }
          <LPAREN>
          [
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )*
          ]
          <RPAREN>
          statement = inStatement()
          { out = new ProcedureDef(line, name, args, statement); }
        | LOOKAHEAD( <DEF> [<LAZY>] <VARIABLE> <LPAREN> )
          { Logger.debug("Found a Function definition"); }
          <DEF> { line = token.beginLine; }
          [<LAZY> { lazy = true; }]
          <VARIABLE> { name = token.image; }
          <LPAREN>
          [
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )*
          ]
          <RPAREN>
          expression = inExpression()
          { out = new FunctionDef(line, name, args, expression, lazy); }
        | LOOKAHEAD( <FUNCTOR> [<VARIABLE>] )
          <FUNCTOR> { line = token.beginLine; }
          [ <VARIABLE> { name = token.image; } ]
          (
            ( <IMPORT> importClause = importClause() { imports.add(importClause); }
              (
                <COMMA> importClause = importClause() { imports.add(importClause); }
              )*
            )
            |
            ( <EXPORT> exportClause = exportClause() { exports.add(exportClause); }
              (
                <COMMA> exportClause = exportClause() { exports.add(exportClause); }
              )*
            )
          )*
          statement = inStatement()
          { out = new FunctorDef(line, name, imports, exports, statement); }
        | LOOKAHEAD( <CLASS> <VARIABLESTRICT> )
          <CLASS> { line = token.beginLine; }
          <VARIABLESTRICT> { name = token.image; }
          (
            aDescriptor = classDescriptor() { descriptors.add(aDescriptor); }
          )*
          <LCURLY>
          (
            classElement = classElementDef()
            { if(classElement instanceof MethodDef){
                methods.add((MethodDef) classElement);
              } else if(classElement instanceof ClassDescriptor) {
                descriptors.add((ClassDescriptor) classElement);
              }
            }
          )* <RCURLY>
          { out = new ClassDef(line, name, descriptors, methods); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable declaration (anonymous).
 *
 * <pre>
 *   nestDecAnonym ::= DEFPROC DOLLAR LPAREN [pattern {COMMA pattern}] RPAREN inStatement
 *                 | DEF [LAZY] DOLLAR LPAREN [pattern {COMMA pattern}] RPAREN inExpression
 *                 | FUNCTOR [DOLLAR] {
 *                     (IMPORT importClause {COMMA importClause}+)
 *                     | (EXPORT exportClause {COMMA exportClause}+)
 *                   }
 *                   inStatement
 *                 | CLASS DOLLAR {classDescriptor} LCURLY
 *                   {classElementDef} RCURLY
 * </pre>
 *
 * @return an AST for a nestDecAnonym.
 */
private Expression nestDecAnonym(): {
    int line = 0;
    Expression out = null;
    InStatement statement = null;
    InExpression expression = null;
    boolean lazy = false;
    Pattern aPattern = null;
    ArrayList<Pattern> args = new ArrayList<Pattern>();
    ImportClause importClause = null;
    ArrayList<ImportClause> imports = new ArrayList<ImportClause>();
    ExportClause exportClause = null;
    ArrayList<ExportClause> exports = new ArrayList<ExportClause>();
    ClassDescriptor aDescriptor = null;
    ArrayList<ClassDescriptor> descriptors = new ArrayList<ClassDescriptor>();
    ClassElement classElement = null;
    ArrayList<MethodDef> methods = new ArrayList<MethodDef>();
}
{
    try {
        <DEFPROC> { line = token.beginLine; }
          <DOLLAR> <LPAREN>
          [
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )*
          ]
          <RPAREN>
          statement = inStatement()
          { out = new ProcedureDefAnonym(line, args, statement, null); }
        | <DEF> { line = token.beginLine; }
          [<LAZY> { lazy = true; }]
          <DOLLAR> <LPAREN>
          [
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )*
          ]
          <RPAREN>
          expression = inExpression()
          { out = new FunctionDefAnonym(line, args, expression, lazy, null); }
        | <FUNCTOR> { line = token.beginLine; }
          [ <DOLLAR> ]
          (
            ( <IMPORT> importClause = importClause() { imports.add(importClause); }
              (
                <COMMA> importClause = importClause() { imports.add(importClause); }
              )*
            )
            |
            ( <EXPORT> exportClause = exportClause() { exports.add(exportClause); }
              (
                <COMMA> exportClause = exportClause() { exports.add(exportClause); }
              )*
            )
          )*
          statement = inStatement()
          { out = new FunctorDefAnonym(line, imports, exports, statement, null); }
        | <CLASS> { line = token.beginLine; }
          <DOLLAR>
          (
            aDescriptor = classDescriptor() { descriptors.add(aDescriptor); }
          )*
          <LCURLY>
          (
            classElement = classElementDef()
            { if(classElement instanceof MethodDef){
                methods.add((MethodDef) classElement);
              } else if(classElement instanceof ClassDescriptor) {
                descriptors.add((ClassDescriptor) classElement);
              }
            }
          )* <RCURLY>
          { out = new ClassDefAnonym(line, descriptors, methods, null); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse an import clause of a functor. There can be multiple of them in an import statement,
 * separated by commas.
 *
 * <pre>
 *   importClause ::= variable
 *                    [LPAREN (atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]} RPAREN]
 *                    [FROM atom]
 * </pre>

 * @return an AST for an ImportClause.
 */
 private ImportClause importClause(): {
    int line = 0;
    String name = null;
    String label = null;
    Variable var = null;
    Map<String, Variable> map = new HashMap<String, Variable>();
    String source = null;
}
{
    try {
        <VARIABLESTRICT> { line = token.beginLine; name = token.image; }
        [
          <LPAREN> (<ATOM>|<INT>) { label = token.image; }
            [<COLON> <VARIABLE> { var = new Variable(token.beginLine, token.image, true, false); }]
            { map.put(label, var); } //var will be null most of the time
          ( LOOKAHEAD( <COMMA> (<ATOM>|<INT>) )
            <COMMA> (<ATOM>|<INT>) { label = token.image; var = null; } //reset the previous values !
            [<COLON> <VARIABLE> { var = new Variable(token.beginLine, token.image, true, false); }]
            { map.put(label, var); } //var will be null most of the time
          )*
        ]
        [
          <FROM> <ATOM> { source = token.image; }
        ]
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new ImportClause(line, name, map, source); }
}

/**
 * Parse an export clause of a functor. There can be multiple of them in an export statement,
 * separated by commas.
 *
 * <pre>
 *   exportClause ::= [(atom|int) COLON] variable
 * </pre>

 * @return an AST for an ExportClause.
 */
 private ExportClause exportClause(): {
    int line = 0;
    String label = null;
    Variable var = null;
}
{
    try {
        [
          (<ATOM>|<INT>) { line = token.beginLine; label = token.image; }
        ]
        <VARIABLE>
        { line = (line!=0 ? line : token.beginLine);
          var = new Variable(token.beginLine, token.image, false, true); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new ExportClause(line, label, var); }
}

/**
 * Parse a class element definition. It can return a Method or
 * a class descriptor (extension, attribute, or property)
 *
 * <pre>
 *   classElementDef ::= DEF methHead [ASSIGN variable] (inExpression|inStatement)
 *                      | classDescriptor
 * </pre>

 * @return an AST for a ClassElement.
 */
 private ClassElement classElementDef(): {
    int line = 0;
    ClassElement out = null;
    MethodHead aMethodHead = null;
    Variable name = null;
    InExpression expression = null;
    InStatement statement = null;
    ClassDescriptor descriptor = null;
}
{
    try {
          LOOKAHEAD( <DEF> methHead() )
          <DEF> { line = token.beginLine; }
          aMethodHead = methHead()
          [<ASSIGN> <VARIABLE> { name = new Variable(line, token.image, true, false); }]
          ( //LOOKAHEAD( inExpression() )
            //expression = inExpression()
          //| //TODO find a way to re-add this later-on
            //LOOKAHEAD( inStatement() )
            statement = inStatement()
          )
          { out = new MethodDef(line, aMethodHead, name, expression, statement); }
        | LOOKAHEAD( classDescriptor() )
          descriptor = classDescriptor()
          { out = descriptor; }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a case/match statement clause.
 *
 * <pre>
 *   caseStatementClause ::= pattern {(LAND|LOR) conditionalExpression} IMPL inStatement
 * </pre>

 * @return an AST for a caseStatementClause.
 */
private CaseStatementClause caseStatementClause(boolean firstClausePassed): {
    int line = 0;
    CaseStatementClause out = null;
    InStatement statement = null;
    Pattern pattern = null;
    Operator op = null;
    ArrayList<Operator> ops = new ArrayList<Operator>();
    Expression expression = null;
    ArrayList<Expression> exprs = new ArrayList<Expression>();
}
{
    try {
        pattern = pattern() { line = pattern.line(); }
        (
          (<LAND> { op = Operator.LAND; }
          | <LOR> { op = Operator.LOR; })
          expression = conditionalExpression()
          { ops.add(op); exprs.add(expression); }
        )*
        <IMPL> statement = inStatement()
        { out = new CaseStatementClause(line, pattern, ops, exprs, statement, !firstClausePassed); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a case/match expression clause.
 *
 * <pre>
 *   caseExpressionClause ::= pattern {(LAND|LOR) conditionalExpression} IMPL inExpression
 * </pre>

 * @return an AST for a caseExpressionClause.
 */
private CaseExpressionClause caseExpressionClause(boolean firstClausePassed): {
    int line = 0;
    CaseExpressionClause out = null;
    InExpression expression = null;
    Pattern pattern = null;
    Operator op = null;
    ArrayList<Operator> ops = new ArrayList<Operator>();
    Expression aExpression = null;
    ArrayList<Expression> exprs = new ArrayList<Expression>();
    {Logger.debug("Entering caseExpressionClause()");}
}
{
    try {
        pattern = pattern() { line = pattern.line(); }
        (
          LOOKAHEAD( (<LAND>|<LOR>) expression() )
          (<LAND> { op = Operator.LAND; }
          | <LOR> { op = Operator.LOR; })
          aExpression = expression()
          { ops.add(op); exprs.add(aExpression); }
        )*
        <IMPL> expression = inExpression()
        { out = new CaseExpressionClause(line, pattern, ops, exprs, expression, !firstClausePassed); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse an assignment expression.
 *
 * <pre>
 *   assignmentExpression ::= conditionalExpression
 * </pre>
 *
 * @return an AST for an AssignmentExpression.
 */
private Expression assignmentExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering assignmentExpression()");}
}
{
    try {
        lhs = conditionalExpression() { line = token.beginLine; }
        [ LOOKAHEAD( <ASSIGN> assignmentExpression() )
            (
            <ASSIGN> rhs = assignmentExpression()
                { lhs = new OperationAssignment(line, lhs, rhs); }
             //| <PLUSASS>  rhs = assignmentExpression()
             //   { lhs = new OperationPlusAssignment(line, lhs, rhs); }
             //| <MINUSASS> rhs = assignmentExpression()
             //   { lhs = new OperationMinusAssignment(line, lhs, rhs); }
            )
        ]
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse an assignment statement.
 *
 * <pre>
 *   assignmentStatement ::= variable ASSIGN expression
 * </pre>
 *
 * @return an AST for an AssignmentStatement.
 */
private Statement assignmentStatement(): {
    int line = 0;
    Statement out = null;
    Variable lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering assignmentStatement()");}
}
{
    try {
        <VARIABLE>
        { lhs = new Variable(token.beginLine, token.image, false, false); }
        //Do not activate readmode : OperationAssignment#codegen() will handle the correct operator t write (= vs :=)
        <ASSIGN> rhs = expression()
        { out = new OperationAssignment(line, lhs, rhs); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a conditional expression.
 *
 * <pre>
 *   conditionalExpression ::= conditionalOrExpression
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */
private Expression conditionalExpression(): {
    //int line = 0;
    Expression lhs = null;
    {Logger.debug("Entering conditionalExpression()");}
}
{
    try {
        lhs = conditionalOrExpression() //{ line = token.beginLine; }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse a conditional OR expression.
 *
 * <pre>
 *   conditionalOrExpression ::= conditionalAndExpression {LOR conditionalAndExpression}
 * </pre>
 *
 * @return an AST for a conditionalOrExpression.
 */
private Expression conditionalOrExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering conditionalOrExpression()");}
}
{
    try {
        lhs = conditionalAndExpression() { line = token.beginLine; }
        ( LOOKAHEAD( <LOR> conditionalAndExpression() )
            <LOR> rhs = conditionalAndExpression()
            { lhs = new OperationLogicalOr(line, lhs, rhs); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse a conditional AND expression.
 *
 * <pre>
 *   conditionalAndExpression ::= equalityExpression {LAND equalityExpression}
 * </pre>
 *
 * @return an AST for a conditionalAndExpression.
 */
private Expression conditionalAndExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering conditionalAndExpression()");}
}
{
    try {
        lhs = equalityExpression() { line = token.beginLine; }
        ( LOOKAHEAD( <LAND> equalityExpression() )
            <LAND> rhs = equalityExpression()
            { lhs = new OperationLogicalAnd(line, lhs, rhs); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse an equality expression.
 *
 * <pre>
 *   equalityExpression ::= relationalExpression {EQUAL relationalExpression}
 * </pre>
 *
 * @return an AST for an equalityExpression.
 */
private Expression equalityExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering equalityExpression()");}
}
{
    try {
        lhs = relationalExpression() { line = token.beginLine; }
        ( LOOKAHEAD( <EQUAL> relationalExpression() )
            <EQUAL> rhs = relationalExpression()
            { lhs = new OperationEqual(line, lhs, rhs); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse a relational expression.
 *
 * <pre>
 *   relationalExpression ::= additiveExpression {(GT|GE|LT|LE) additiveExpression}
 * </pre>
 *
 * @return an AST for a relationalExpression.
 */
private Expression relationalExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering relationalExpression()");}
}
{
    try {
        lhs = additiveExpression() { line = token.beginLine; }
        [ LOOKAHEAD( (<GT>|<GE>|<LT>|<LE>) additiveExpression() )
           ( <GT> rhs = additiveExpression() { lhs = new OperationGreaterThan(line, lhs, rhs); }
            | <GE> rhs = additiveExpression() { lhs = new OperationGreaterEqual(line, lhs, rhs); }
            | <LT> rhs = additiveExpression() { lhs = new OperationSmallerThan(line, lhs, rhs); }
            | <LE> rhs = additiveExpression() { lhs = new OperationSmallerEqual(line, lhs, rhs); }
           )
        ]
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse an additive expression.
 *
 * <pre>
 *   additiveExpression ::= multiplicativeExpression {(PLUS|MINUS) multiplicativeExpression}
 * </pre>
 *
 * @return an AST for an additiveExpression.
 */
private Expression additiveExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering additiveExpression()");}
}
{
    try {
        lhs = multiplicativeExpression() { line = token.beginLine; }
        ( LOOKAHEAD( (<PLUS>|<MINUS>) multiplicativeExpression() )
          (
            <PLUS> rhs = multiplicativeExpression()
            { Logger.debug("Found an additiveExpression");
              lhs = new OperationPlus(line, lhs, rhs); }
          | <MINUS> rhs = multiplicativeExpression()
                { lhs = new OperationMinus(line, lhs, rhs); }
          )
        )*
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse a multiplicative expression.
 *
 * <pre>
 *   multiplicativeExpression ::= unaryExpression {(STAR|SLASH|MODULO) unaryExpression}
 * </pre>
 *
 * @return an AST for a multiplicativeExpression.
 */
private Expression multiplicativeExpression(): {
    int line = 0;
    Expression lhs = null;
    Expression rhs = null;
    {Logger.debug("Entering multiplicativeExpression()");}
}
{
    try {
        lhs = unaryExpression() { line = token.beginLine; }
        ( LOOKAHEAD( (<STAR>|<SLASH>|<MODULO>) unaryExpression() )
          ( <STAR> rhs = unaryExpression()
                { lhs = new OperationMultiplication(line, lhs, rhs); }
          | <SLASH> rhs = unaryExpression()
                { lhs = new OperationDivision(line, lhs, rhs); }
          | <MODULO> rhs = unaryExpression()
                { lhs = new OperationModulo(line, lhs, rhs); }
          )
        )*
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return lhs; }
}

/**
 * Parse an unary expression.
 *
 * <pre>
 *   unaryExpression ::= (INC|DEC|MINUS|PLUS) unaryExpression //TODO we will not support all of these in the first release
 *                          | simpleUnaryExpression
 * </pre>
 *
 * @return an AST for an unaryExpression.
 */
private Expression unaryExpression(): {
    int line = 0;
    Expression expr = null;
    Expression expr2 = null;
    {Logger.debug("Entering unaryExpression()");}
}
{
    try {
        LOOKAHEAD( simpleUnaryExpression() )
        expr = simpleUnaryExpression()
        //| <INC> { line = token.beginLine; }
        //expr2 = unaryExpression()
        //{ expr = new OperationPreIncr(line, expr2); }
        //| <DEC> { line = token.beginLine; }
        //    expr2 = unaryExpression()
        //    { expr = new OperationPreDecr(line, expr2); }
        |
         <PLUS> { line = token.beginLine; }
            expr2 = unaryExpression()
            { expr = new OperationValidate(line, expr2); }
        | <MINUS> { line = token.beginLine; }
            expr2 = unaryExpression()
            { expr = new OperationNegate(line, expr2); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return expr; }
}

/**
 * Parse a simple unary expression.
 *
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                          | postfixExpression
 * </pre>
 *
 * @return an AST for a simpleUnaryExpression.
 */
private Expression simpleUnaryExpression(): {
    int line = 0;
    Expression expr = null;
    Expression expr2 = null;
}
{
    try {
        LOOKAHEAD(postfixExpression() )
        expr = postfixExpression()
      | LOOKAHEAD( <LNOT> )
        <LNOT> { line = token.beginLine; }
        expr2 = unaryExpression()
        { expr = new OperationLogicalNot(line, expr2); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return expr; }
}

/**
 * Parse a postfix expression.
 *
 * <pre>
 *   postfixExpression ::= primary {(DEC|INC)} //TODO we will not support these in the first release
 * </pre>
 *
 * @return an AST for a postfixExpression.
 */

private Expression postfixExpression(): {
    int line = 0;
    Expression out = null;
    Expression expr = null;
    Variable variable = null;
    {Logger.debug("Entering postfixExpression()");}
}
{
    try {
        out = primary() //{ line = primaryExpr.line(); }
        //( LOOKAHEAD( <DEC>|<INC> )
        //    (
        //    <DEC> { primaryExpr = new OperationPostDecr(line, primaryExpr); }
        //    | <INC> { primaryExpr = new OperationPostInc(line, primaryExpr); }
        //    )
        //)*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[]{RCURLY}, e );
    }
    { return out; }
}

/**
 * Parse a primary expression.
 *
 * <pre>
 *   primary ::= variable | int | float | character | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL
 *             | variable LPAREN [expression {COMMA expression}] RPAREN
 *             | variable DOT variable [LPAREN [expression {COMMA expression}] RPAREN]
 *             | THIS DOT variable LPAREN [expression {COMMA expression}] RPAREN
 *             | SUPER [LPAREN variableStrict RPAREN]
 *                      DOT variable LPAREN [expression {COMMA expression}] RPAREN
 *             | parExpression
 * </pre>
 *
 * @return an AST for a primaryExpression.
 */
private Expression primary(): {
    int line = 0;
    Expression out = null;
    Expression expr = null;
    Variable variable = null;
    String name = null;
    Expression arg = null;
    ArrayList<Expression> args = new ArrayList<Expression>();
    {Logger.debug("Entering primary()");}
}
{
    try {

          LOOKAHEAD( parExpression() )
          out = parExpression()
        | LOOKAHEAD( <UNIT> ) <UNIT> { out = new Literal(token.beginLine, Type.UNIT, false); }
        | LOOKAHEAD( <TRUE> ) <TRUE> { out = new Literal(token.beginLine, Type.BOOLEAN, true, false); }
        | LOOKAHEAD( <FALSE> ) <FALSE> { out = new Literal(token.beginLine, Type.BOOLEAN, false, false); }
        | LOOKAHEAD( <UNDERSCORE> ) <UNDERSCORE> { out = new Literal(token.beginLine, Type.UNDERSCORE, false); }
        | LOOKAHEAD( <NIL> ) <NIL> { out = new Literal(token.beginLine, Type.NIL, false); }
        | LOOKAHEAD( <INT> ) <INT> { out = new Literal(token.beginLine, Type.INT, token.image, false); }
        | LOOKAHEAD( <FLOAT> ) <FLOAT> { out = new Literal(token.beginLine, Type.FLOAT, token.image, false); }
        | LOOKAHEAD( <CHARACTER> ) <CHARACTER> { out = new Literal(token.beginLine, Type.CHAR, token.image, false); }
        | LOOKAHEAD( <STRING> ) <STRING> { out = new Literal(token.beginLine, Type.STRING, token.image, false); }
        | LOOKAHEAD( <VARIABLE> <DOT> <VARIABLE> )
          <VARIABLE> { variable = new Variable(token.beginLine, token.image, false, false);}
          <DOT> <VARIABLE>
          { name = token.image;
            out = new ExpressionSelectionFeature(line, variable, name); }
          [ LOOKAHEAD( <LPAREN> )
              <LPAREN>
              [
                arg = expression() { args.add(arg); }
                (
                  <COMMA> arg = expression() { args.add(arg); }
                )*
              ]
              <RPAREN>
              { out = new ExpressionSelectionMethod(line, variable, name, args); }
          ]
        | LOOKAHEAD( <VARIABLE> <LPAREN> expression() )
          <VARIABLE> { line = token.beginLine; name = token.image;
            Logger.debug("Found a CallFunction to "+name+" at line "+line); }
          <LPAREN>
          [
            expr = expression() { args.add(expr); }
            (
              <COMMA> expr = expression() { args.add(expr); }
            )*
          ]
          <RPAREN>
          { out = new CallFunction(line, name, args); }
        | LOOKAHEAD( <THIS> [<DOT> (<VARIABLE>|<VARIABLESTRICT>) <LPAREN>] )
          <THIS> { line = token.beginLine; out = new ThisExpression(line); }
            [
            <DOT> (<VARIABLE>|<VARIABLESTRICT>) { variable = new Variable(line, token.image, false, false);}
            <LPAREN>
            [
                arg = expression() { args.add(arg); }
                (
                    <COMMA> arg = expression() { args.add(arg); }
                )*
            ]
            <RPAREN>
            { out = new Call(line, variable.name(), args); }
            ]
        | LOOKAHEAD( <SUPER> )
          <SUPER> { line = token.beginLine; }
            [ LOOKAHEAD( <LPAREN> <VARIABLESTRICT> <RPAREN> )
              <LPAREN> <VARIABLESTRICT> { name = token.image; } <RPAREN>
            ]
            <DOT> (<VARIABLE>|<VARIABLESTRICT>) { variable = new Variable(token.beginLine, token.image, false, false);}
            <LPAREN>
            [ LOOKAHEAD( expression() )
                arg = expression() { args.add(arg); }
                (
                    <COMMA> arg = expression() { args.add(arg); }
                )*
            ]
            <RPAREN>
            { out = new Call(line, variable.name(), args, name); }
        | LOOKAHEAD( <VARIABLE> [<DOT> expression()] )
          <VARIABLE> { variable = new Variable(token.beginLine, token.image, false, true); out=variable; }
          [
          <DOT> expr = expression()
          { out = new ExpressionSelectionList(line, variable, expr);
            Logger.debug("Found a list selection arg:"+variable.name()); }
          ]
    }
    catch ( ParseException e ) {
        recoverFromError( new int[]{RCURLY}, e );
    }
    { Logger.debug("Returning primary "+((out instanceof Variable) ? ((Variable)out).name() :
        ((out instanceof Literal) ? ((Literal)out).image() : "")));

    return out; }
}

/**
 * Parse a term (Used in functions/procedures/methods calls, but also in many other places as a term to an operation).
 *
 * <pre>
 *   term ::= assignmentExpression
 *            | atomLisp LPAREN [[feature COLON]pattern {COMMA [feature COLON]pattern} [COMMA ELLIPSIS]] RPAREN //TODO enforce atomLisp for records
 *            | LPAREN expression {HASHTAG expression}+ RPAREN
 *            | LPAREN expression {COLCOL expression}+ RPAREN
 *            | LBRACK [expression {COMMA expression}] RBRACK
 * </pre>

 * @return an AST for a term.
 */
private Expression term(): {
    int line = 0;
    Expression out = null;
    String value = null;
    Feature aFeature = null;
    Expression val = null;
    Map<Feature, Expression> map = new HashMap<Feature, Expression>();
    int lostLabelsCounter = 0;
    boolean more = false;
    ArrayList<Expression> args = new ArrayList<Expression>();
    {Logger.debug("Entering term()");}
}
{
    try {
          LOOKAHEAD( <ATOMLISP> <LPAREN> )
          <ATOMLISP> { line = token.beginLine; value = token.image; } <LPAREN>
          [
          [ LOOKAHEAD( feature() <COLON> )
            aFeature = feature() <COLON>
            { map.put(aFeature, null); }
          ]
          val = expression()
            { if(aFeature==null){
              map.put(new Feature(line, lostLabelsCounter), val);
              lostLabelsCounter++;
            } else {
              map.put(aFeature, val);
            }}
          ( LOOKAHEAD( <COMMA> )
            <COMMA> {aFeature = null;}
            [ LOOKAHEAD( feature() <COLON> )
              aFeature = feature() <COLON>
              { map.put(aFeature, null); }
            ]
            val = expression()
            { if(aFeature==null){
                map.put(new Feature(line, lostLabelsCounter), val);
                lostLabelsCounter++;
              } else {
                map.put(aFeature, val);
              }}
          )*
          [
            <COMMA> <ELLIPSIS> { more = true; }
          ]
          ]
          <RPAREN>
          { out = new Record(line, value, map, more); }
        | LOOKAHEAD( <LPAREN> expression() (<HASHTAG> expression())+ <RPAREN> )
          <LPAREN> { line = token.beginLine; }
          val = expression() { args.add(val); }
          (<HASHTAG> val = expression() { args.add(val); })+
          <RPAREN>
          { out = new Tuple(line, args); }
        | LOOKAHEAD( <LPAREN> expression() (<COLCOL> expression())+ <RPAREN> )
          <LPAREN> { line = token.beginLine; }
          val = expression() { args.add(val); }
          (<COLCOL> val = expression() { args.add(val); })+
          <RPAREN>
          { out = new List(line, args, true); }
        | LOOKAHEAD( <LBRACK> expression() )
          <LBRACK> { line = token.beginLine; }
          val = expression() { args.add(val); }
          (
            <COMMA>
            val = expression() { args.add(val); }
          )*
          <RBRACK>
         { out = new List(line, args, false); }
        | LOOKAHEAD( assignmentExpression() )
          out = assignmentExpression()
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
/**
 * Parse a pattern (Used in functions/procedures/methods signatures and match blocks).
 *
 * <pre>
 *   pattern ::= variable | UNDERSCORE | NIL
 *            | int | float | character | string | UNIT | TRUE | FALSE
 *            | atomLisp LPAREN [[feature COLON]pattern {COMMA [feature COLON]pattern} [COMMA ELLIPSIS]] RPAREN
 *            | LPAREN pattern {HASHTAG pattern}+ RPAREN
 *            | LPAREN pattern {COLCOL pattern}+ RPAREN
 *            | LBRACK [pattern {COMMA pattern}] RBRACK
 *            | LPAREN pattern RPAREN
 * </pre>

 * @return an AST for a patern.
 */
private Pattern pattern(): {
    int line = 0;
    Pattern out = null;
    boolean bool = true;
    String value = null;
    Feature aFeature = null;
    Pattern val = null;
    Map<Feature, Pattern> map = new HashMap<Feature, Pattern>();
    boolean more = false;
    ArrayList<Pattern> patterns = new ArrayList<Pattern>();
    int lostLabelsCounter = 0;
    {Logger.debug("Entering pattern()");}
}
{
    try {
          <UNIT> { out = new Literal(token.beginLine, Type.UNIT, true); }
        |
          <TRUE> { out = new Literal(token.beginLine, Type.BOOLEAN, true, true); }
        |
          <FALSE> { out = new Literal(token.beginLine, Type.BOOLEAN, false, true); }
        |
          <UNDERSCORE> { out = new Literal(token.beginLine, Type.UNDERSCORE, true); }
        |
          <NIL> { out = new Literal(token.beginLine, Type.NIL, true); }
        |
          <INT> { out = new Literal(token.beginLine, Type.INT, token.image, true); }
        |
          <FLOAT> { out = new Literal(token.beginLine, Type.FLOAT, token.image, true); }
        |
          <CHARACTER> { out = new Literal(token.beginLine, Type.CHAR, token.image, true); }
        |
          <STRING> { out = new Literal(token.beginLine, Type.STRING, token.image, true); }
        |
          <VARIABLE> { out = new Variable(token.beginLine, token.image, true, true, false); }
        |
          <ATOMLISP> { line = token.beginLine; value = token.image; } //This is a record pattern
          <LPAREN>
          [
          [ LOOKAHEAD( feature() )
            aFeature = feature() <COLON>
            { map.put(aFeature, null); }
          ]
          val = pattern()
          { if(aFeature==null){
               map.put(new Feature(line, lostLabelsCounter), val);
               lostLabelsCounter++;
           } else {
               map.put(aFeature, val);
           }
          }
           ( LOOKAHEAD( <COMMA> [feature()] pattern() )
             <COMMA>
             [ LOOKAHEAD( feature() )
              aFeature = feature() <COLON>
              { map.put(aFeature, null); }
             ]
             val = pattern()
             { if(aFeature==null){
                 map.put(new Feature(line, lostLabelsCounter), val);
                 lostLabelsCounter++;
               } else {
                 map.put(aFeature, val);
               }}
           )*
           [<COMMA> <ELLIPSIS> { more = true; }]
           ] <RPAREN>
           { out = new Record(line, value, map, more, true); }
        | LOOKAHEAD( <LPAREN> pattern() <HASHTAG> pattern() )
          <LPAREN> { line = token.beginLine; }
          val = pattern() { patterns.add(val); }
          (<HASHTAG> val = pattern() { patterns.add(val); })+
          <RPAREN>
          { out = new Tuple(line, patterns, true); }
        | LOOKAHEAD( <LPAREN> pattern() <COLCOL> pattern() )
          <LPAREN> { line = token.beginLine; }
          val = pattern() { patterns.add(val); }
          (<COLCOL> val = pattern() { patterns.add(val); })+
          <RPAREN>
          { out = new List(line, patterns, true, true); Logger.debug("Returning List pattern"); }
        | LOOKAHEAD( <LBRACK> pattern() )
          <LBRACK> { line = token.beginLine; }
          val = pattern() { patterns.add(val); }
          (
            <COMMA>
            val = pattern() { patterns.add(val); }
          )*
         <RBRACK>
          { out = new List(line, patterns, false, true); }
        | LOOKAHEAD( <LPAREN> pattern() <RPAREN> )
          <LPAREN>
          val = pattern() { out = val; }
          <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a variables declaration group.
 *
 * <pre>
 *   declarationPart ::= (VAL|VAR) variable [ASSIGN expression]
 *                        {COMMA variable [ASSIGN expression]}
 *                      | nestDecVariable
 * </pre>
 *
 * @return an AST for a declarationPart.
 */
private Declaration declarationPart(): {
    int line = 0;
    boolean constant;
    Declaration out = null;
    Variable variable = null;
    Expression value = null;
    Map<Variable, Expression> map = new HashMap<Variable, Expression>();
    {Logger.debug("Entering declarationPart()");}
}
{
  try {
      LOOKAHEAD( (<VAL>|<VAR>) <VARIABLE> )
      (
        <VAL> { line = token.beginLine; constant = true; }
      | <VAR> { line = token.beginLine; constant = false; }
      )
      <VARIABLE> { variable = new Variable(line, token.image, constant, true, false);
          map.put(variable, null);
          Logger.debug("Declaring variable "+token.image+" as a constant("+constant+")"); }
      [<ASSIGN> value = expression()
      { map.put(variable, value); }]
      ( LOOKAHEAD( <COMMA> <VARIABLE> )
        <COMMA> <VARIABLE> { variable = new Variable(line, token.image, constant, true, false);
           map.put(variable, null);
           Logger.debug("Declaring variable "+token.image+" as a constant("+constant+")"); }
        [<ASSIGN> value = expression()
        { map.put(variable, value); }]
      )*
      { out = new Declaration(line, map, constant); }

   |  LOOKAHEAD( <DEFPROC> | <DEF> | <CLASS> | <FUNCTOR> )
      out = nestDecVariable()
  }
  catch ( ParseException e ) {
      recoverFromError(new int[]{RCURLY}, e);
  }
  { return out; }
}

/**
 * Parse a loop declaration.
 * A loop declaration can be an iterator or a feature declaration.
 * An iterator has the form: <it>Pat</it> in <it>Generator</it> where <it>Generator</it> describes
 * how to generate the successive values for pattern <it>Pat<it/> whose variables are local
 * to the loop.
 * If a loop comprises multiple loop declarations, the generators are stepped in parallel and
 * the loop terminates as soon as one of the generators runs out of values.
 * @source http://mozart2.org/mozart-v1/doc-1.4.0/loop/node1.html#chapter.official
 * <pre>
 *   loopDec ::= variable IN expression DOTDOT expression [SEMI expression]
 *                | variable IN expression SEMI expression [SEMI expression]
 *                | variable IN expression
 *                | BREAK COLON variable //TODO implement loop features later
 *                | CONTINUE COLON variable
 *                | RETURN COLON variable
 *                | DEFLT COLON expression
 *                | COLLECT COLON variable
 * </pre>
 *
 * @return an AST for a loop declaration.
 */
private LoopDeclaration loopDeclaration(): {
    int line = 0;
    LoopDeclaration out = null;
    Variable var = null;
    Expression generator = null;
    Expression init = null;
    Expression cond = null;
    Expression step = null;
    Expression end = null;
    //Feature feat = null; //TODO implement loop features later
}
{
    try {
        LOOKAHEAD(<VARIABLE> <IN> expression() <DOTDOT> )
        <VARIABLE> { line = token.beginLine; var = new Variable(line, token.image, true, false); }
          <IN> init = expression()
          <DOTDOT> end = expression()
          [
            <SEMI> step = expression()
          ]
          {out = new LoopDeclaration(line, var, init, null, step, end); }
      | LOOKAHEAD( <VARIABLE> <IN> expression() <SEMI> )
        <VARIABLE> { line = token.beginLine; var = new Variable(line, token.image, true, false); }
          <IN> init = expression()
          <SEMI> step = expression()
          [
            <SEMI> end  = expression()
            { cond=step; step=end; }
          ]
          { out = new LoopDeclaration(line, var, init, cond, step, null); }
      | LOOKAHEAD( <VARIABLE> <IN> expression() )
        <VARIABLE> { line = token.beginLine; var = new Variable(line, token.image, true, false); }
          <IN> generator = expression()
          { out = new LoopDeclaration(line, var, generator); }
    }
    catch ( ParseException e ) {
        recoverFromError( new int[]{RCURLY}, e );
    }
    { return out; }
}

/**
 * Parse a feature. For now, it is only defined as an atomLisp, but this might change in the future.
 *
 * <pre>
 *   feature ::= atomLisp
 * </pre>
 *
 * @return an AST for a feature.
 */
private Feature feature(): {
    int line = 0;
    String image = null;
}
{
    try {
        <ATOMLISP> { line = token.beginLine; image = token.image; }
    } catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new Feature(line, image); }
}

/**
 * Parse a class descriptor. This only includes a list of parent classes, as well as attributes/properties.
 * Methods definitions are in the class body.
 *
 * <pre>
 *   classDescription ::= EXTENDS variableStrict {COMMA variableStrict}+
 *                        | ATTR variable [ASSIGN expression]
 *                        | PROP variable //TODO properties will not be supported in the first release

 //TODO add features (they are public attributes if I understand correctly) [not for the first release]
 * </pre>
 *
 * @return an AST for a class descriptor.
 */
private ClassDescriptor classDescriptor(): {
    int line = 0;
    ClassDescriptor out = null;
    ArrayList<String> extensions = new ArrayList<String>();
    Variable var = null;
    Expression expr = null;
}
{
    try {
        <EXTENDS> { line = token.beginLine; }
          <VARIABLESTRICT> { extensions.add(token.image); }
          (
            <COMMA>
            <VARIABLESTRICT> { extensions.add(token.image); }
          )*
          { out = new ClassDescriptor(line, SubType.EXTENSION, extensions); }
        | <ATTR> { line = token.beginLine; }
          <VARIABLE> { var = new Variable(line, token.image, false, true, false); }
          [
            <ASSIGN> expr = expression()
          ]
          { out = new ClassDescriptor(line, SubType.ATTRIBUTE, var, expr); }
        | <PROP> { line = token.beginLine; }
          <VARIABLE>
          { var = new Variable(line, token.image, true, false);
            out = new ClassDescriptor(line, SubType.PROPERTY, var, null); }
    } catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a method head. This can be seen as its signature
 *
 * <pre>
 *   methHead ::= (variableStrict | variable) //variableStrict => private, variable => public
 *                  LPAREN [methArg {COMMA methArg} [COMMA ELLIPSIS]] RPAREN
 * </pre>
 *
 * @return an AST for a MethHead.
 */
private MethodHead methHead(): {
    int line = 0;
    boolean priv = false;
    String name = null;
    MethodArg arg = null;
    ArrayList<MethodArg> args = new ArrayList<MethodArg>();
    boolean moreArgs = false;
}
{
    try {
        (
          <VARIABLESTRICT> { line = token.beginLine; priv = true; name = token.image; }
          | <VARIABLE> { line = token.beginLine; priv = false; name = token.image; }
        )
        <LPAREN>
        [
          arg = methArg() { args.add(arg); }
          ( LOOKAHEAD( <COMMA> methArg() )
            <COMMA> arg = methArg() { args.add(arg); }
          )*
          [
            <COMMA> <ELLIPSIS>
            { moreArgs = true; }
          ]
        ]
        <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new MethodHead(line, name, priv, args, moreArgs); }
}

/**
 * Parse a method argument.
 *
 * <pre>
 *   methArg ::= [feature COLON] (variable | UNDERSCORE) //TODO read http://mozart2.org/mozart-v1/doc-1.4.0/tutorial/node10.html#chapter.classes for $ explanation & default values
 *                  [LE expression]
 * </pre>
 *
 * @return an AST for a MethArg.
 */
private MethodArg methArg(): {
    int line = 0;
    Feature feature = null;
    String name = null;
    Expression defaultValue = null;
    {Logger.debug("Entering methArg()");}
}
{
    try {
        [
        feature = feature() { feature.line(); }
        <COLON>
        ]
        (
          <VARIABLE> { name = token.image; Logger.debug("Found methArg called "+name); }
          | <UNDERSCORE> { name = token.image; }
        )
        [
          <LE> defaultValue = expression()
        ]
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new MethodArg(line, feature, name, defaultValue); }
}