\begin{lstlisting}[label={lst:newOzEBNF},frame=single,basicstyle=\footnotesize,escapeinside={(*}{*)}]
EBNF grammar for newOz, suitable for recursive descent
- Note that the concatenation symbol in EBNF (comma) is
omitted for readability reasons
- <T> represents a generic definition
(think about Java generic types)
Notation      Meaning
===========================================================================
(*\epsilon*)             singleton containing the empty word
(*$(w)$*)           grouping of regular expressions
(*$[w]$*)           union of \epsilon with the set of words w (optional group)
(*$\{w\}$*)          zero or more times w
(*$\{w\}+$*)         one or more times w
(*$w_1~w_2$*)         concatenation of (*$w_1$*) with (*$w_2$*)
(*$w_1 | w_2$*)         logical union of (*$w_1$*) and (*$w_2$*) (OR)
(*$w_1-w_2$*)       difference of (*$w_1$*) and (*$w_2$*)

// Interactive statements
interStatement ::= statement
| DECLARE LCURLY {declarationPart}+ [interStatement] RCURLY

statement ::= nestCon(statement)
| nestDec(variable)
| SKIP
| statement statement

expression ::= nestCon(expression)
| nestDec(DOLLAR)
| expressions evalBinOp expression
| DOLLAR
| term
| monOp expression
| THIS
| UNDERSCORE //TODO to stay coherent with oldOz ?

//TODO expression simplifiable ?
inStatement ::= LCURLY [{declarationPart}+] statement RCURLY

//TODO expression simplifiable ?
inExpression ::= LCURLY [{declarationPart}+]
                [statement] expression RCURLY

in(statement) ::= inStatement

in(expression) ::= inExpression

// This is in the sense of the old Oz "in" keyword
blockIn(<T>) ::= LCURLY (in(<T>) | WHITESPACE) RCURLY
//TODO whitespace rly ou erreur ds these ?

//Here, <T> is statement or expression
nestCon(<T>) ::= expression (ASSIGN | DEFINE) expression
| expression LPAREN {expression COMMA} RPAREN
| blockIn(<T>)
| LPAREN in(<T>) RPAREN
| IF LPAREN expression RPAREN blockIn(<T>)
  {ELSE IF LPAREN expression RPAREN blockIn(<T>)}
  [ELSE blockIn(<T>)]
| MATCH expression LCURLY {CASE pattern
   [(LAND | LOR) expression] RBARROW (blockIn(<T>) | in(<T>))}+
  [ELSE blockIn(<T>)] RCURLY
| FOR LPAREN {loopDec}+ RPAREN blockIn(<T>)
| TRY blockIn(<T>) [CATCH LCURLY
   {CASE pattern IMPL (blockIn(<T>) | in(<T>))} RCURLY]
  [FINALLY blockIn(<T>)]
| RAISE blockIn(expression)
| THREAD blockIn(<T>)
| LOCK [LPAREN expression RPAREN] blockIn(<T>)

//Here, <T> is always DOLLAR or a variable
nestDec(T) ::= DEFPROC <T> LPAREN {pattern COMMA} RPAREN
  blockIn(statement)
| DEF [LAZY] <T> LPAREN {pattern COMMA} RPAREN
  blockIn(expression)
//TODO the following lines are a mess -> rewrite from thesis' text
| FUNCTOR [<T>] {
[IMPORT ({variable [AT atom]
| variable LPAREN {(atom | int) [COLON variable] COMMA}+ RPAREN) COMMA
}+]
[EXPORT {[(atom | int) COLON] variable COMMA}+]
}
blockIn(statement)
| CLASS <T> {classDescriptor} LCURLY
{DEF methHead [ASSIGN variable] (blockIn(expression) | blockIn(statement))} RCURLY

// Terms and patterns
term ::= [LNOT] variable | int | float | character | atom
| string | UNIT | TRUE | FALSE | UNDERSCORE //TODO UNDERSCORE : seems to me but not in the book ?!
| label LPAREN {[feature COLON] expression COMMA} RPAREN
| expression consBinOp expression
| LBRACK {expression COMMA}+ RBRACK

pattern ::= [LNOT] variable | int | float | character | atom
| string | UNIT | TRUE | FALSE | UNDERSCORE //TODO UNDERSCORE : seems to me but not in the book ?!
| label LPAREN {[feature COLON] pattern COMMA}
  [COMMA DOTDOTDOT] RPAREN
| pattern consBinOp pattern
| LBRACK {pattern}+ RBRACK

declarationPart ::= {(VAL | VAR) {(variable | pattern)
  ASSIGN (expression | statement) COMMA}+ [SEMI]}

loopDec ::= variable IN expression
  [DOTDOT expression] [SEMI expression]
| variable IN expression SEMI expression SEMI expression
| break COLON variable
| CONTINUE COLON variable
| RETURN COLON variable
| DEFAULT COLON expression
| COLLECT COLON variable

binaryOp ::= evalBinOp | consBinOp

consBinOp ::= HASHTAG | PIPE

evalBinOp ::= PLUS | MINUS | STAR | SLASH | MODULO | DOT
| LAND | LOR | DEFINE | COMMA | ASSIGN | EQUAL
| NE | LT | LE | GT | GE

label ::= UNIT | TRUE | FALSE | variable | atom

feature ::= UNIT | TRUE | FALSE | variable | atom | int

classDescription ::= EXTENDS {expression}+
| PROP {expression}+
| ATTR {attrInit}+

attrInit ::= ([LNOT] variable | atom | UNIT | TRUE | FALSE)
  [COLON expression]

methHead ::= ([LNOT] varStrict | atomLisp | UNIT | TRUE | FALSE)
  [LPAREN {methArg COMMA} [COMMA DOTDOTDOT] RPAREN]
  [ASSIGN variable]

methArg ::= [feature COLON] (variable | UNDERSCORE | DOLLAR)
  [ASSIGN expression]

varStrict ::= UPPERCASE {ALPHANUM}
| APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE

variable ::= (UPPERCASE | LOWERCASE) {ALPHANUM}
| APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE

atom ::= atomLisp
| RACCENT {ATOMCHAR | PSEUDOCHAR} RACCENT

string ::= QUOTE {STRINGCHAR | PSEUDOCHAR} QUOTE

character ::= CHARINT
| AND CHARCHAR
| AND PSEUDOCHAR

atomLisp ::= APOSTROPHE (LOWERCASE | UPPERCASE)
  {alphanumericChar} - keywords //TODO

\end{lstlisting}
