// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

// This is the input file to JavaCC for generating a scanner and
// a parser for newOz. From the specification in this file, JavaCC,
// among other files, generates a JavaCCParser.java file
// under this directory. This file is the parser. The code
// between  PARSER_BEGIN( JavaCCParser ) and
// PARSER_END( JavaCCParser ) is copied verbatim to this file. JavaCC
// also generates a JavaCCParserTokenManager.java file which is the
// scanner.

PARSER_BEGIN( JavaCCParser )

package com.barassolutions;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Parser generated by JavaCC. It parses a newOz compilation block
 * (program file), taking tokens from the scanner (also generated by
 * JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;

    /** Name of the file that is parsed. */
    private String fileName;

    /**
     * Pull out the ambiguous part of a name and return it.
     *
     * @param name with an ambiguous part (possibly).
     * @return ambiguous part or null.
     */
    private AmbiguousName ambiguousPart(TypeName name) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf('.');
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName(name.line(), qualifiedName.substring( 0, lastDotIndex));
    }

    /**
     * Report a syntax error.
     *
     * @param message message identifying the error.
     * @param args related values.
     */
    private void reportParserError(String message, Object... args) {
        errorHasOccurred = true;
        System.err.printf("%s:%d: ", fileName, token.beginLine);
        System.err.printf(message, args);
        System.err.println();
    }

    /**
     * Recover from the parser error that occurred by skipping to
     * any of the specified tokens.
     *
     * Current error recovery mechanism is rather simple-minded and is
     * based on skipping all the tokens until a SEMI or an EOF is
     * encountered. This scheme can be enhanced by passing in the
     * FOLLOW-SET of the non-terminal at hand.
     *
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event
     * of a parser error.
     */
    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[ i ].length; j++) {
                expected.append("\n");
                expected.append("\t");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought", getToken( 1 ), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought", getToken(1), expected);
        }

        // Recover
        boolean loop = true;
        do {
            token = getNextToken();
            for (int i : skipTo) {
                if (token.kind == i) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }

    /**
     * Set the name of the file that is being parsed.
     *
     * @param fileName name of the file.
     */
    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     *
     * @return true or false.
     */
    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The newOz lexical grammar starts here       //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"} //TODO missing \v

// Single-line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Multi-line comment -- ignored
SKIP: {<"/*"> : MULTI_COMMENT}
<MULTI_COMMENT>
SKIP : {<"*/"> : DEFAULT | < ~[] >}

// Reserved words
TOKEN : {
  < AT: "at" >
| < ATTR: "attr" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHOICE: "choice" > //TODO What's this ?
| < CLASS: "class" >
| < COLLECT: "collect" > //TODO What's this ?
| < COND: "cond" > //TODO What's this ?
| < CONTINUE: "continue" >
| < DECLARE: "declare" >
| < DEFINE: "define" >
| < DEF: "def" >
| < DEFPROC: "defproc" >
| < DEFLT: "default" >
| < DIS: "dis" > //TODO What's this ?
| < DO: "do" >
| < ELSE: "else" >
//| < ELSECASE: "elsecase" > TODO ?
//| < ELSEOF: "elseof" > TODO ?
| < EXPORT: "export" >
| < EXTENDS: "extends" >
| < FAIL: "fail" > //TODO What's this ?
| < FALSE: "false" >
| < FEAT: "feat" > //TODO What's this ?
| < FINALLY: "finally" >
| < FOR: "for" >
| < FROM: "from" >
| < FUNCTOR: "functor" >
| < IF: "if" >
| < IMPORT: "import" >
| < IN: "in" >
| < LAZY: "lazy" >
| < LOCK: "lock" >
| < MATCH: "match" >
| < METH: "meth" >
| < NOT: "not" > //TODO What's this ?
| < OF: "of" >
| < OR: "or" >
| < PREPARE: "prepare" > //TODO What's this ?
| < PROP: "prop" > //TODO What's this ?
| < RAISE: "raise" >
| < REQUIRE: "require" > //TODO What's this ?
| < RETURN: "return" >
| < SKP: "skip" >
| < THIS: "this" >
| < THREAD: "thread" >
| < TRUE: "true" >
| < TRY: "try" >
| < UNIT: "unit" >
| < VAL: "val" >
| < VAR: "var" >
}

// Operators
TOKEN : {
  <ASSIGN: "=">
| <COLASSIGN: ":=">
| <EQUAL: "==">
| <NE: "\\=">
| <LT: "<">
| <GT: ">">
| <LE: "=<">
| <GE: ">=">
| <LBARROW: "<=">
| <IMPL: "=>">
//| <AND: "&"> //TODO DELETED
| <LAND: "&&">
//| <PIPE: "|"> //TODO DELETED
| <LOR: "||">
| <LNOT: "!">
| <LNOTNOT: "!!">
| <MINUS: "-">
| <PLUS: "+">
| <STAR: "*">
| <SLASH: "/">
| <BACKSLASH: "\\">
| <MODULO: "%">
| <HASHTAG: "#">
| <UNDERSCORE: "_">
| <DOLLAR: "$">
| <APOSTROPHE: "'">
| <QUOTE: "\"">
| <LACCENT: "`">
| <RACCENT: "´">
| <HAT: "^">
| <BOX: "[]">
| <TILDE: "~">
| <DEGREE: "°">
| <COMMERCAT: "@">
| <LARROW: "<-">
| <RARROW: "->">
| <FDASSIGN: "=:">
| <FDNE: "\\=:">
| <FDLT: "<:">
| <FDLE: "=<:">
| <FDGT: ">:">
| <FDGE: ">=:">
| <COLCOL: "::">
| <COLCOLCOL: ":::">
}

// Separators
TOKEN : {
 <COMMA: ",">
| <LBRACK: "[">
| <LCURLY: "{">
| <LPAREN: "(">
| <RBRACK: "]">
| <RCURLY: "}">
| <RPAREN: ")">
| <SEMI: ";">
| <COLON: ":">
| <DOT: ".">
| <DOTDOT: "..">
| <ELLIPSIS: "...">
}

// Identifiers & litterals
TOKEN : {
  < VARIABLE: ((<UPPERCASE>(<ALPHANUM>)*) | <LACCENT>(<VARIABLE_CHAR>|<PSEUDO_CHAR>)<LACCENT>) >
| < ATOM: (<LOWERCASE>(<ALPHANUM>)* | <APOSTROPHE>(<ATOM_CHAR>|<PSEUDO_CHAR>)<APOSTROPHE>) >
| < LABEL: (<VARIABLE>|<ATOM>|<BOOLEAN>|<UNIT>)<LPAREN> >
| < IDENTIFIER: (<LETTER>|"_") (<ALPHANUM>)* >
| < INT_LITERAL: (<DECINT> | <HEXINT> | <OCTINT> | <BININT>) >
| < FLOAT: ("~")? (<DIGIT>)+ <DOT> (<DIGIT>)* (("e"|"E")("~")?(<DIGIT>)+)? >
| < STRING: <QUOTE>(<STRING_CHAR> | <PSEUDO_CHAR>)<QUOTE> >
| < CHAR: <DEGREE> (~["\\"] | <PSEUDO_CHAR>)>
| < #BOOLEAN: (<TRUE> | <FALSE>) >
| < DECINT: ("~")? ("0" | <NON_ZERO_DIGIT>(<DIGIT>)*) >
| < HEXINT: ("~")? "0" ("x"|"X") (<HEXDIGIT>)+ >
| < OCTINT: ("~")? "0" (<OCTDIGIT>)+ >
| < BININT: ("~")? "0" ("b"|"B") (<BINDIGIT>)+ >
| < #LETTER: (<UPPERCASE> | <LOWERCASE>) >
| < #DIGIT: ["0"-"9"] >
| < #OCTDIGIT: ["0"-"7"] >
| < #HEXDIGIT: (<DIGIT> | ["A"-"F"] | ["a"-"f"]) >
| < #BINDIGIT: ["0"-"1"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
//| < CHAR_LITERAL : "'" (<ESC> | ~["'","\\","\n","\r"]) "'" >
//| < STRING_LITERAL : "\"" (<ESC> | ~["\"","\\","\n","\r"])* "\"" >
| < #UPPERCASE: ["A"-"Z"] >
| < #LOWERCASE: ["a"-"z"] >
| < #CHARINT: (["0"-"9"]|["1"-"9"]["0"-"9"]|"1"["0"-"9"]["0"-"9"]|"2"["0"-"4"]["0"-"9"]|"25"["0"-"5"])> // [0-255]
| < #ALPHANUM: (<LETTER> | <DIGIT> | <UNDERSCORE>) >
| < #ATOM_CHAR: ~["'","\\"] > //TODO also NUL char (=ISO char 0)
| < #STRING_CHAR: ~["\"","\\"] > // TODO also NUL char
| < #VARIABLE_CHAR: ~["`","\\"] > //TODO also NUL char
| < #ESCAPE_CHAR: ("a"|"b"|"f"|"n"|"r"|"t"|"v"|<BACKSLASH>|<APOSTROPHE>|<QUOTE>|<LACCENT>|<DEGREE>) >
//| < #ESC: <BACKSLASH> <ESCAPE_CHAR> >
//| < #CHARESC: <DEGREE> <BACKSLASH> ("f"|"n"|"r"|"t"|"v"|"240") >
// In the classes of words <variable>, <atom>, <string>, and <character> we use pseudo-characters,
// which represent single characters in different notations.
| < #PSEUDO_CHAR: (<BACKSLASH><OCTDIGIT><OCTDIGIT><OCTDIGIT>) | (<BACKSLASH>("x"|"X")<HEXDIGIT><HEXDIGIT>) | (<BACKSLASH><ESCAPE_CHAR>) >
} //TODO more work here

// For anything else, we return an ERROR token. Without this
// definition the TokenManager will throw an Error when a lexical
// error occurs, making it impossible to recover from it. So we
// define this ERROR token.
TOKEN:
{
 < ERROR: ~[] >
}

/////////////////////////////////////////////////////////
//       The newOz syntactic grammar starts here         //
/////////////////////////////////////////////////////////
// Construct this from http://mozart2.org/mozart-v1/doc-1.4.0/notation/node3.html#chapter.context-free

/**
 * Parse a compilation block (a program file) and construct an AST
 * for it. After constructing the Parser, this is its entry point.
 *
 * <pre>
 *   compilationBlock ::= FUNCTOR
 *                        {importExportStatement}
 *
 *
 {typeDeclaration}
 *                       EOF
 * </pre>
 *
 * @return an AST for a compilationUnit.
 */


/**
 * Parse a block.
 *
 * <pre>
 *   block ::= LCURLY {blockStatement} RCURLY
 * </pre>
 *
 * @return an AST for a block.
 */
private Block block(): {
    int line = 0;
    Statement aStatement = null;
    ArrayList<Statement> statements = new ArrayList<Statement>();
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        (
            aStatement = blockStatement()
            { statements.add( aStatement ); }
        )*
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new Block( line, statements ); }
}

/**
 * Parse a block statement, that is a statement allowed to appear in a block.
 *
 * <pre>
 *   blockStatement ::= localVariableDeclarationStatement
 *                    | statement
 * </pre>
 *
 * @return an AST for a blockStatement.
 */
private Statement blockStatement(): {
    Statement statement = null;
}
{
    try {
        LOOKAHEAD( type() <IDENTIFIER> ) //TODO type in newOz = var or val (to discuss)
        statement = localVariableDeclarationStatement() |
        statement = statement()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return statement; }
}

/**
 * Parse a local variable declaration statement.
 *
 * <pre>
 *   localVariableDeclarationStatement ::= type variableDeclarators
 * </pre>
 *
 * @return an AST for a variableDeclaration.
 */
private VariableDeclaration localVariableDeclarationStatement(): {
    int line = 0;
    Type type = null;
    ArrayList<VariableDeclarator> vdecls = null;
    ArrayList<String> mods = new ArrayList<String>();
}
{
    try {
        type = type() { line = token.beginLine; }
        vdecls = variableDeclarators( type )
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new VariableDeclaration( line, mods, vdecls ); }
}

/**
 * Parse variable declarators.
 *
 * <pre>
 *   variableDeclarators ::= variableDeclarator
 *                             {COMMA variableDeclarator}
 * </pre>
 *
 * @param type type of the variables. //TODO so val or var
 * @return a list of variable declarators.
 */
private ArrayList<VariableDeclarator> variableDeclarators( Type type ): {
    VariableDeclarator aVariableDeclarator = null;
    ArrayList<VariableDeclarator> variableDeclarators = new ArrayList<VariableDeclarator>();
}
{
    try {
        aVariableDeclarator = variableDeclarator( type )
        { variableDeclarators.add( aVariableDeclarator ); }
        (
            <COMMA> aVariableDeclarator = variableDeclarator( type )
            { variableDeclarators.add( aVariableDeclarator ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return variableDeclarators; }
}

/**
 * Parse a variable declarator.
 *
 * <pre>
 *   variableDeclarator ::= IDENTIFIER
 *                          [ASSIGN variableInitializer]
 * </pre>
 *
 * @param type type of the variable.
 * @return an AST for a variableDeclarator.
 */
private VariableDeclarator variableDeclarator( Type type ): {
    int line = 0;
    Expression initial = null;
    String name = "";
}
{
    try {
        <IDENTIFIER> { line = token.beginLine; name = token.image; }
        [
            <ASSIGN> initial = variableInitializer( type )
        ]
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new VariableDeclarator( line, name, type, initial ); }
}

/**
 * Parse a variable initializer.
 *
 * <pre>
 *   variableInitializer ::= expression
 * </pre>
 *
 * @param type type of the variable.
 * @return an AST for a variableInitializer.
 */
private Expression variableInitializer( Type expected ): {
    Expression initializer = null;
}
{
    try {
        initializer = expression()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e );
    }
    { return initializer; }
}

/**
 * Parse a type.
 *
 * <pre>
 *   type ::= VAL | VAR
 * </pre>
 *
 * @return an instance of Type.
 */
private Type type(): {
    Type type = null;
}
{
    try {
        <VAL> { type = Type.VAL; } |
        <VAR> { type = Type.VAR; }
    }
    catch ( ParseException e ) {
       recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return type; }
}

/**
 * Parse a statement.
 *
 * <pre>
 *   statement ::= block
 *               | SKP
 *               | conditionalStatement
 *               | loopStatement
 *               | TRY block [CATCH patternMatchBlock] [FINALLY block]
 *               | MATCH patternMatchBlock
 *               | THREAD block
 *               | LOCK LPAREN expression RPAREN block
 *               | RAISE blockExpression //TODO
 *               | RETURN [expression] //TODO
 *               | statementExpression //Expressions that have a side-effect
 * </pre>
 *
 * @return an AST for a statement.
 */
private Statement statement(): {
    int line = 0;
    Statement statement = null;
    Expression test = null;
    Statement consequent = null;
    Statement alternate = null;
    Statement body = null;
    Expression expr = null;
}
{
    try {
        statement = block() |
        <SKP>
        { statement = new EmptyStatement( line ); } |
        statement = conditionalStatement() |
        statement = loopStatement() |
        <TRY> { line = token.beginLine; }
        body = block()
        [
            LOOKAHEAD( <CATCH> )
            <CATCH>
            consequent = patternMatchBlock()
        ]
        [
            LOOKAHEAD( <FINALLY> )
            <FINALLY>
            alternate = block()
        ]
        { statement = new TryStatement(line, body, consequent, alternate); } |
        <MATCH> { line = token.beginLine; }
        expr = expression()
        body = patternMatchBlock()
        { statement = new MatchStatement(line, expression, body); } |
        <THREAD> { line = token.beginLine; }
        body = block()
        { statement = new ThreadStatement(line, body); } |
        <LOCK> { line = token.beginLine; }
        <LPAREN>
        expr = expression()
        <RPAREN>
        body = block()
        { statement = new LockStatement(line, expr, body); } |
        <RAISE> { line = token.beginLine; }
        expr = blockExpression()
        { statement = new RaiseStatement( line, expr ); } |
        <RETURN> { line = token.beginLine; }
        [
            expr = expression()
        ]
        <SEMI> //TODO temporary to remove warning
        { statement = new ReturnStatement(line, expr); } |
        // Must be a statementExpression
        statement = statementExpression()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return statement; }
}

/**
 * Parse a conditional statement.
 *
 * <pre>
 *   conditionalStatement ::= IF parExpression block [ELSE statement]
 * </pre>

 * @return an AST for a conditional statement.
 */
private ConditionalStatement conditionalStatement(): {
    int line = 0;
    Statement statement = null;
    Expression test = null;
    Statement consequent = null;
    Statement alternate = null;
}
{
        <IF> { line = token.beginLine; }
        test = parExpression()
        consequent = statement()

        // Even without the lookahead below, which is added to
        // suppress JavaCC warnings, dangling if-else problem is
        // resolved by binding the alternate to the closest
        // consequent.
        [
            LOOKAHEAD( <ELSE> )
            <ELSE> alternate = statement()
        ]
        { statement = new ConditionalStatement(line, test, consequent, alternate); }
}

/**
 * Parse a loop statement.
 *
 * <pre>
 *   loopStatement ::= FOR LPAREN loopDeclaration RPAREN block
 * </pre>

 * @return an AST for a loop statement.
 */
private Statement loopStatement(): {
    int line = 0;
    Statement statement = null;
    LoopDeclaration loopDecl = null;
    Statement body = null;
}
{
        <FOR> { line = token.beginLine; }
        <LPAREN>
        loopDec = loopDeclaration()
        <RPAREN>
        body = block()
        { statement = new ForStatement(line, loopDec, body); }
}

/**
 * Parse a parenthesized expression.
 *
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 *
 * @return an AST for a parExpression.
 */
private Expression parExpression(): {
    Expression expr = null;

}
{
    try {
        <LPAREN> expr = expression() <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a block expression.
 *
 * <pre>
 *   blockExpression ::= LCURLY expression RCURLY
 * </pre>
 *
 * @return an AST for a blockExpression.
 */
private Expression blockExpression(): {
    Expression expr = null;

}
{
    try {
        <LCURLY> expr = expression() <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a loop declaration.
 *
 * <pre>
 *   loopDeclaration ::= loopDecPart {, loopDecPart}*
 * </pre>
 *
 * @return an AST for a loop declaration.
 */
private LoopDeclaration loopDeclaration(): {
    int line = 0;
    LoopDecPart part = null;
    ArrayList<LoopDecPart> list = new ArrayList<LoopDecPart>();
}
{
    try {
        part = loopDecPart()
        {
          line = token.beginLine;
          list.add(part);
        }
        (
          <COMMA>
          part = loopDecPart()
          { list.add(part); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new LoopDeclaration(line, list); }
}

/**
 * Parse a loop declaration part.
 *
 * <pre>
 *   loopDecPart ::= IDENTIFIER IN expression
 *                | IDENTIFIER IN expression SEMI expression SEMI expression
 *                | IDENTIFIER IN LPAREN expression SEMI expression SEMI expression RPAREN
 *                | IDENTIFIER IN expression DOTDOT expression SEMI expression
 *                | IDENTIFIER IN expression DOTDOT expression
 *                | IDENTIFIER IN expression SEMI expression
 * </pre>
 * //TODO implement "features" http://mozart2.org/mozart-v1/doc-1.4.0/loop/node1.html#chapter.official
 * @return an AST for a loop declaration.
 */
private LoopDecPart loopDecPart(): {
    int line = 0;
    LoopDecPart part = null;
    Identifier var = null;
    Expression range1 = null;
    Expression range2 = null;
    BoolExpression condition = null;
    Expression step = null;
}
{
    try {
        var = identifier() { line = token.beginLine; }
        <IN>
        (
          LOOKAHEAD(expression() <DOTDOT>)
          range1 = expression()
          <DOTDOT>
          range2 = expression()
          { part = new LoopDecPart(line, var, range1, range2); }
          [
            <SEMI>
            step = expression()
            { part.setStep(step); }
          ]
          |
          LOOKAHEAD(expression() <SEMI> expression() <SEMI>)
          range1 = expression() <SEMI>
          range2 = expression()
          { part = new LoopDecPart(line, var, range1, true, range2); }
          [
            <SEMI>
            step = expression()
            { condition = range2;
              part = new LoopDecPart(line, var, range1, condition, step); }
          ]
          |
          <LPAREN>
          range1 = expression() <SEMI>
          condition = expression() <SEMI>
          step = expression() <RPAREN>
          { part = new LoopDecPart(line, var, range1, condition, step); }
        )
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return part; }
}

/**
 * Parse a statement expression.
 *
 * <pre>
 *   statementExpression ::= expression // but must have
 *                                      // side-effect, eg i++
 * </pre>
 * TODO adapt this for newOz
 * @return an AST for a statementExpression.
 */
private Statement statementExpression(): {
    int line = 0;
    Expression expr = null;
}
{
    try {
        expr = expression()
        {
            line = expr.line();
            if ( expr instanceof Assignment
              || expr instanceof PreIncrementOp
              || expr instanceof PostDecrementOp
              || expr instanceof MessageExpression
              || expr instanceof SuperConstruction
              || expr instanceof ThisConstruction
              || expr instanceof NewArrayOp ) { //TODO others. This might be the fix for the last 2 warning in javacc
                // So as not to save on stack
                expr.isStatementExpression = true;
            }
            else {
                reportParserError( "Invalid statement expression; " +
                    "it does not have a side-effect" );
            }
        }
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new StatementExpression( line, expr ); }
}

/**
 * Parse an identifier.
 *
 * <pre>
 *   identifier ::= IDENTIFIER
 * </pre>
 *
 * @return an instance of TypeName.
 */
private TypeName identifier(): {
    int line = 0;
    String identifier = null;
}
{
    try {
        <IDENTIFIER>
        {
            line = token.beginLine;
            identifier = token.image;
        }
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return
         new TypeName( line, identifier ); }
}

/**
 * Parse a pattern matching block.
 *
 * <pre>
 *   patternMatchBlock ::= LCURLY {expression IMPL [block]}+ [ELSE block] RCURLY
 * </pre>
 *
 * @return an AST for a blockExpression.
 */
private PatternMatchBlock patternMatchBlock(): {
    int line = 0;
    Expression cond = null;
    Statement conseq = null;
    Map<Expression, Statement> cases = new HashMap<Expression, Statement>();
    Statement elseCase = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        (
          cond = expression() <IMPL>
          { cases.put(cond, null); }
          [
            conseq = block() //TODO we only support blocks for now
            { consequences.put(cond, conseq); }
          ]
        )+
        [
          <ELSE>
          elseCase = block()
        ]
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new PatternMatchBlock(line, cases, elseCase); }
}

/**
 * An expression.
 *
 * <pre>
 *   expression ::= assignmentExpression
 * </pre>
 *
 * @return an AST for an expression.
 */
private Expression expression(): {
    Expression expr = null;
}
{
    try {
        expr = assignmentExpression()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse an assignment expression.
 *
 * <pre>
 *   assignmentExpression ::=
 *       conditionalExpression // level 13
 *           [ASSIGN  // conditionalExpression
 *            assignmentExpression]
 * </pre>
 *
 * @return an AST for an assignmentExpression.
 */
private Expression assignmentExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalExpression() { line = token.beginLine; }
        [
            <ASSIGN>
            rhs = assignmentExpression()
            { lhs = new AssignOp( line, lhs, rhs ); }
        ]
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse a conditional expression.
 *
 * <pre>
 *   conditionalExpression ::= conditionalOrExpression
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */
 private Expression conditionalExpression(): {
    Expression expr = null;
}
{
    try {
        expr = conditionalOrExpression()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a conditional-or expression.
 *
 * <pre>
 *   conditionalOrExpression ::= conditionalAndExpression
 *                                  {LOR conditionalAndExpression}
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */
private Expression conditionalOrExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalAndExpression() { line = token.beginLine; }
        (
            <LOR>
            rhs = conditionalAndExpression()
            { lhs = new LogicalOrOp( line, lhs, rhs ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse a conditional-and expression.
 *
 * <pre>
 *   conditionalAndExpression ::= equalityExpression // level 10
 *                                  {LAND equalityExpression}
 * </pre>
 *
 * @return an AST for a conditionalExpression.
 */
private Expression conditionalAndExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = equalityExpression() { line = token.beginLine; }
        (
            <LAND>
            rhs = equalityExpression()
            { lhs = new LogicalAndOp( line, lhs, rhs ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse an equality expression.
 *
 * <pre>
 *   equalityExpression ::= relationalExpression  // level 6
 *                            {EQUAL relationalExpression}
 * </pre>
 *
 * @return an AST for an equalityExpression.
 */
private Expression equalityExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = relationalExpression() { line = token.beginLine; }
        (
            <EQUAL>
            rhs = relationalExpression()
            { lhs = new EqualOp( line, lhs, rhs ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse a relational expression.
 *
 * <pre>
 *   relationalExpression ::= additiveExpression  // level 5
 *                              [(GT | LE | LT | GE) additiveExpression]
 * </pre>
 *
 * @return an AST for a relationalExpression.
 */
private Expression relationalExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = additiveExpression() { line = token.beginLine; }
        [
            <GT>
            rhs = additiveExpression()
            { lhs = new GreaterThanOp( line, lhs, rhs ); } |
            <LE>
            rhs = additiveExpression()
            { lhs = new LessEqualOp( line, lhs, rhs ); } |
            <LT>
            rhs = additiveExpression()
            { lhs = new LessThanOp( line, lhs, rhs ); } |
            <GE>
            rhs = additiveExpression()
            { lhs = new GreaterEqualOp( line, lhs, rhs ); }
        ]
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse an additive expression.
 *
 * <pre>
 *   additiveExpression ::= multiplicativeExpression // level 3
 *                            {MINUS multiplicativeExpression}
 * </pre>
 *
 * @return an AST for an additiveExpression.
 */
private Expression additiveExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = multiplicativeExpression() { line = token.beginLine; }
        (
            <PLUS>
            rhs = multiplicativeExpression()
            { lhs = new PlusOp( line, lhs, rhs ); } |
            <MINUS>
            rhs = multiplicativeExpression()
            { lhs = new SubtractOp( line, lhs, rhs ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse a multiplicative expression.
 *
 * <pre>
 *   multiplicativeExpression ::= unaryExpression  // level 2
 *                                  {STAR unaryExpression}
 * </pre>
 *
 * @return an AST for a multiplicativeExpression.
 */
private Expression multiplicativeExpression(): {
    int line = 0;
    Expression lhs = null, rhs = null;
}
{
    try {
        lhs = unaryExpression() { line = token.beginLine; }
        (
            <STAR>
            rhs = unaryExpression()
            { lhs = new MultiplyOp( line, lhs, rhs ); } |
            <SLASH>
            rhs = unaryExpression()
            { lhs = new DivisionOp( line, lhs, rhs ); }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return lhs; }
}

/**
 * Parse an unary expression.
 *
 * <pre>
 *   unaryExpression ::= PLUS unaryExpression // level 1
 *                     | TILDE unaryExpression
 *                     | simpleUnaryExpression
 * </pre>
 *
 * @return an AST for an unaryExpression.
 */
private Expression unaryExpression(): {
    int line = 0;
    Expression expr = null, unaryExpr = null;
}
{
    try {
//        <PLUS> { line = token.beginLine; } TODO removed bcs of conflict with binary + operator
//        unaryExpr = unaryExpression()
//        { expr = new ValidateOp( line, unaryExpr ); } | //Validate as opposed to negate
        <TILDE> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new NegateOp( line, unaryExpr ); } |
        expr = simpleUnaryExpression()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a simple unary expression.
 *
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                           | primary
 * </pre>
 *
 * @return an AST for a simpleUnaryExpression.
 */
private Expression simpleUnaryExpression(): {
    int line = 0;
    Type type = null;
    Expression expr = null, unaryExpr = null;
}
{
    try {
        <LNOT> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new LogicalNotOp( line, unaryExpr ); } |
        expr = primary()
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr ; }
}

/**
 * Parse a primary expression.
 *
 * <pre>
 *   primary ::= parExpression
 *             | THIS [DOT IDENTIFIER [arguments]]
 *             | literal
 *             | qualifiedIdentifier [arguments]
 * </pre>
 *
 * @return an AST for a primary.
 */
private Expression primary(): {
    int line = 0;
    Expression expr = null;
    Expression newTarget = null;
    ArrayList<Expression> args = null;
    TypeName id = null;
}
{
    try {
        expr = parExpression() |
        <THIS> { line = token.beginLine; expr = new This( line ); }
        [
            <DOT> <IDENTIFIER>
            {
                newTarget = new This( line );
                expr = new FieldSelection( line, newTarget, token.image );
            }
            [
                args = arguments()
                { expr = new MessageExpression( line, newTarget, null, token.image, args ); }
            ]
        ] |
        expr = literal() |

        // Language is ambiguous here. JavaCC warns about not being
        // able to choose between qualifiedIdentifier and selector.
        // Semantic analysis will sort it out.
        id = qualifiedIdentifier()
        {
            line = id.line();
            if ( ambiguousPart( id ) == null ) {
                expr = new Variable( line, id.simpleName() );
            }
            else {
                expr = new FieldSelection( line, ambiguousPart( id ),
                                            null, id.simpleName() );
            }
        }
        [
            args = arguments()
            { expr = new MessageExpression( line, null,
                  ambiguousPart( id ), id.simpleName(), args ); }
        ]
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a qualified identifier.
 *
 * <pre>
 *   qualifiedIdentifier ::= IDENTIFIER {DOT IDENTIFIER}
 * </pre>
 *
 * @return an instance of TypeName.
 */
private TypeName qualifiedIdentifier(): {
    int line = 0;
    String qualifiedIdentifier = "";
}
{
    try {
        <IDENTIFIER>
        {
            line = token.beginLine;
            qualifiedIdentifier = token.image;
        }
        (
            <DOT> <IDENTIFIER>
            { qualifiedIdentifier += "." + token.image; }
        )*
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return new TypeName( line, qualifiedIdentifier ); }
}

/**
 * Parse arguments.
 *
 * <pre>
 *   arguments ::= LPAREN [expression {COMMA expression}] RPAREN
 * </pre>
 *
 * @return a list of expressions.
 */
private ArrayList<Expression> arguments(): {
    ArrayList<Expression> args = new ArrayList<Expression>();
    Expression anExpression = null;
}
{
    try {
        <LPAREN>
        [
            anExpression = expression() { args.add( anExpression ); }
            (
                <COMMA> anExpression = expression()
                { args.add( anExpression ); }
            )*
        ]
        <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return args; }
}

/**
 * Parse a literal.
 *
 * <pre>
 *   literal ::= INT_LITERAL | FLOAT | CHAR | STRING
 *             | TRUE        | FALSE        | NULL
 * </pre>
 *
 * @return an AST for a literal.
 */
private Expression literal(): {
    Expression expr = null;
}
{
    try {
        <INT_LITERAL>
        { expr = new LiteralInt( token.beginLine, token.image ); } |
        <CHAR>
        { expr = new LiteralChar( token.beginLine, token.image ); } |
        <STRING>
        { expr = new LiteralString( token.beginLine, token.image ); } |
        <TRUE>
        { expr = new LiteralTrue( token.beginLine ); } |
        <FALSE>
        { expr = new LiteralFalse( token.beginLine ); } |
        <UNIT>
        { expr = new LiteralUnit( token.beginLine ); } |
        <ATOM>
        { expr = new LiteralAtom( token.beginLine ); }
    }
    catch ( ParseException e ) {
        expr = new WildExpression( token.beginLine );
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}