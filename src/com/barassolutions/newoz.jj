// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

// This is the input file to JavaCC for generating a scanner and
// a parser for newOz. From the specification in this file, JavaCC,
// among other files, generates a JavaCCParser.java file
// under this directory. This file is the parser. The code
// between  PARSER_BEGIN( JavaCCParser ) and
// PARSER_END( JavaCCParser ) is copied verbatim to this file. JavaCC
// also generates a JavaCCParserTokenManager.java file which is the
// scanner.

PARSER_BEGIN( JavaCCParser )

package com.barassolutions;

import java.lang.reflect.Array;import java.util.ArrayList;
import java.util.HashMap;

/**
 * Parser generated by JavaCC. It parses a newOz program file, taking tokens from the scanner
 * (also generated by JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;

    /** Name of the file that is being parsed. */
    private String fileName;

    /**
     * Pull out the ambiguous part of a name and return it.
     *
     * @param name with an ambiguous part (possibly).
     * @return ambiguous part or null.
     */ //TODO what do we do with this ?
    private AmbiguousName ambiguousPart(TypeName name) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf('.');
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName(name.line(), qualifiedName.substring( 0, lastDotIndex));
    }

    /**
     * Report a syntax error.
     *
     * @param message message identifying the error.
     * @param args related values.
     */
    private void reportParserError(String message, Object... args) {
        errorHasOccurred = true;
        System.err.printf("%s:%d: ", fileName, token.beginLine);
        System.err.printf(message, args);
        System.err.println();
    }

    /**
     * Recover from the parser error that occurred by skipping to
     * any of the specified tokens.
     *
     * Current error recovery mechanism is rather simple-minded and is
     * based on skipping all the tokens until a new line or an EOF is
     * encountered. This scheme can be enhanced by passing in the
     * FOLLOW-SET of the non-terminal at hand.
     *
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event
     * of a parser error.
     */
    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[ i ].length; j++) {
                expected.append("\n");
                expected.append("\t");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought", getToken( 1 ), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought", getToken(1), expected);
        }

        // Recover
        boolean loop = true;
        do {
            token = getNextToken();
            for (int i : skipTo) {
                if (token.kind == i) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }

    /**
     * Set the name of the file that is being parsed.
     *
     * @param fileName name of the file.
     */
    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     *
     * @return true or false.
     */
    public boolean errorHasOccurred() {
        return errorHasOccurred;
        }
}}
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The newOz lexical grammar starts here       //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\b"|"\t"|"\n"|"\r"|"\f"|"\v"}

// Single-line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Multi-line comment -- ignored
SKIP: {<"/*"> : MULTI_COMMENT}
<MULTI_COMMENT>
SKIP : {<"*/"> : DEFAULT | < ~[] >}

// Reserved words
TOKEN : {
  < AT: "at" >
| < ATTR: "attr" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
//| < CHOICE: "choice" > //TODO What's this ?
| < CLASS: "class" >
//| < COLLECT: "collect" > //TODO What's this ?
//| < COND: "cond" > //TODO What's this ?
| < CONTINUE: "continue" >
| < DECLARE: "declare" >
| < DEF: "def" >
| < DEFPROC: "defproc" >
| < DEFLT: "default" >
//| < DEFINE: "define" >
//| < DIS: "dis" > //TODO What's dis ?
| < DO: "do" >
| < ELSE: "else" >
//| < ELSECASE: "elsecase" >
//| < ELSEOF: "elseof" >
| < EXPORT: "export" >
| < EXTENDS: "extends" >
//| < FAIL: "fail" > //TODO What's this ?
| < FALSE: "false" >
//| < FEAT: "feat" > //TODO What's this ?
| < FINALLY: "finally" >
| < FOR: "for" >
| < FROM: "from" >
| < FUNCTOR: "functor" >
| < IF: "if" >
| < IMPORT: "import" >
| < IN: "in" >
| < LAZY: "lazy" >
| < LOCK: "lock" >
| < MATCH: "match" >
| < METH: "meth" >
| < NIL: "nil" >
//| < NOT: "not" > //TODO What's this ?
//| < OF: "of" >
| < OR: "or" >
//| < PREPARE: "prepare" > //TODO What's this ?
| < PROP: "prop" >
| < RAISE: "raise" >
//| < REQUIRE: "require" > //TODO What's this ?
| < RETURN: "return" >
| < SKP: "skip" >
| < THIS: "this" >
| < THREAD: "thread" >
| < TRUE: "true" >
| < TRY: "try" >
| < UNIT: "unit" >
| < VAL: "val" >
| < VAR: "var" >
}

// Operators
TOKEN : {
  <ASSIGN: "=">
| <DEFINE: ":=">
| <EQUAL: "==">
| <NE: "\\=">
| <LT: "<">
| <GT: ">">
| <LE: "=<">
| <GE: ">=">
| <LBARROW: "<=">
| <IMPL: "=>">
//| <AND: "&"> //TODO DELETED
| <LAND: "&&">
//| <PIPE: "|"> //TODO DELETED
| <LOR: "||">
| <LNOT: "!">
| <LNOTNOT: "!!">
| <MINUS: "-">
| <PLUS: "+">
| <STAR: "*">
| <SLASH: "/">
| <POSTINC: "++">
| <POSTDEC: "--">
| <BACKSLASH: "\\">
| <MODULO: "%">
| <HASHTAG: "#">
| <UNDERSCORE: "_">
| <DOLLAR: "$">
| <APOSTROPHE: "'">
| <QUOTE: "\"">
| <LACCENT: "`">
| <RACCENT: "´">
| <HAT: "^">
| <BOX: "[]">
//| <TILDE: "~">
| <DEGREE: "°">
//| <COMMERCAT: "@">
//| <LARROW: "<-">
//| <RARROW: "->">
//| <FDASSIGN: "=:">
//| <FDNE: "\\=:">
//| <FDLT: "<:">
//| <FDLE: "=<:">
//| <FDGT: ">:">
//| <FDGE: ">=:">
| <COLCOL: "::">
//| <COLCOLCOL: ":::">
}

// Separators
TOKEN : {
 <COMMA: ",">
| <LBRACK: "[">
| <LCURLY: "{">
| <LPAREN: "(">
| <RBRACK: "]">
| <RCURLY: "}">
| <RPAREN: ")">
| <SEMI: ";">
| <COLON: ":">
| <DOT: ".">
| <DOTDOT: "..">
| <ELLIPSIS: "...">
}

// Identifiers & litterals
TOKEN : {
  < VARIABLESTRICT: ((<UPPERCASE>(<ALPHANUM>)*) | "`"(<ESC> | <PSEUDO_CHAR> | ~["`","\\","\n","\r"])"`") >
| < VARIABLE: <LOWERCASE>(<ALPHANUM>)* >
| < ATOM: (<ATOMLISP> | "´" (<ESC>| <PSEUDO_CHAR> | ~["´","\\","\n","\r"]) "´") >
| < ATOMLISP: <APOSTROPHE> (<LOWERCASE>|<UPPERCASE>) (<ALPHANUM>)* >
| < LABEL: (<VARIABLE>|<ATOM>|<BOOLEAN>|<UNIT>) >
| < STRING: "\"" (<ESC>| <PSEUDO_CHAR> | ~["\"","\\","\n","\r"]) "\"" >
| < CHARACTER: (<DEGREE>(<CHARCHAR> | <PSEUDO_CHAR>) | <CHARINT>) >
| < INT: (<DECINT> | <HEXINT> | <OCTINT> | <BININT>) >
| < FLOAT: (<MINUS>)? (<DIGIT>)+ <DOT> (<DIGIT>)* (("e"|"E")("~")?(<DIGIT>)+)? >
| < BOOLEAN: (<TRUE> | <FALSE>) >

| < #UPPERCASE: ["A"-"Z"] >
| < #LOWERCASE: ["a"-"z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
| < #CHARINT: (["0"-"9"]|["1"-"9"]["0"-"9"]|"1"["0"-"9"]["0"-"9"]|"2"["0"-"4"]["0"-"9"]|"25"["0"-"5"])> // [0-255]
| < #ALPHANUM: (<UPPERCASE> | <LOWERCASE> | <DIGIT> | <UNDERSCORE>) >
| < #DECINT: (<MINUS>)? (<DIGIT> | <NON_ZERO_DIGIT>(<DIGIT>)*) >
| < #HEXINT: (<MINUS>)? "0" ("x"|"X") (<HEXDIGIT>)+ >
| < #OCTINT: (<MINUS>)? "0" (<OCTDIGIT>)+ >
| < #BININT: (<MINUS>)? "0" ("b"|"B") (<BINDIGIT>)+ >
| < #OCTDIGIT: ["0"-"7"] >
| < #HEXDIGIT: (<DIGIT> | ["A"-"F"] | ["a"-"f"]) >
| < #BINDIGIT: ["0"-"1"] >

| < #ESCAPE_CHAR: ("a"|"b"|"f"|"n"|"r"|"t"|"v"|<BACKSLASH>|<APOSTROPHE>|<QUOTE>|<DEGREE>) > //TODO <LACCENT> here iff it is present in <VARIABLESTRICT definition
| < #ESC: <BACKSLASH> <ESCAPE_CHAR> >
| < #CHARCHAR: ~["\\"] >
// In the classes of words <variable>, <atom>, <string>, and <character> we use pseudo-characters,
// which represent single characters in different notations.
| < #PSEUDO_CHAR: (<BACKSLASH><OCTDIGIT><OCTDIGIT><OCTDIGIT>) | (<BACKSLASH>("x"|"X")<HEXDIGIT><HEXDIGIT>) >
}

// For anything else, we return an ERROR token. Without this
// definition the TokenManager will throw an Error when a lexical
// error occurs, making it impossible to recover from it. So we
// define this ERROR token.
TOKEN:
{
 < ERROR: ~[] >
}

/////////////////////////////////////////////////////////
//       The newOz syntactic grammar starts here         //
/////////////////////////////////////////////////////////
// Construct this from http://mozart2.org/mozart-v1/doc-1.4.0/notation/node3.html#chapter.context-free

//TODO still nedds an entry point (filename, functor or not, etc.)

/**
 * Parse an interactive statement and construct an AST
 * for it. After constructing the Parser, this is its entry point.
 *
 * <pre>
 *   interStatement ::= statement
 *                      | DECLARE LCURLY {declarationPart}+ [interStatement] RCURLY EOF
 * </pre>
 *
 * @return an AST for an interStatement.
 */
private InterStatement interStatement(): {
    int line = 0;
    DeclarationPart aDeclarationPart = null;
    ArrayList<DeclarationPart> declarations = new ArrayList<DeclarationPart>();
    InterStatement interStatement = null;
    InterStatement out = null;
}
{
    try {
      (<DECLARE> <LCURLY> { line = token.beginLine; }
      (
          aDeclarationPart = declarationPart()
          { declarations.add(aDeclarationPart); }
      )*
      [
          interStatement = interStatement()
      ]
      <RCURLY> <EOF>
      { out = new InterStatement(line, declarations, interStatement); }) //Declare block
      |
      ( interStatement = statement()
      { line = token.beginLine;
        out = new InterStatement(line, interStatement); //Stand-alone statement
      })
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return out; }
}


/**
 * Parse a statement.
 *
 * <pre>
 *   statement ::= nestConStatement
 *                  | nestDecVariable
 *                  | SKIP
 *                  | SEMI
 *                  //| statement SEMI statemnt //TODO removable if inStatement is correct ?
 *                  | DECLARE statement
 * </pre>
 *
 * @return an AST for a statement.
 */
private Statement statement(): {
    int line = 0;
    Statement statement = null;
}
{
    try {
        statement = nestConStatement() { line = token.beginLine; } |
        statement = nestDecVariable() { line = token.beginLine; } |
        <SKP>
        { line = token.beginLine;
          statement = new SkipStatement(line); } |
        <SEMI> | //Ignore it
        <DECLARE> statement = statement() { line = token.beginLine; }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return new Statement(line, statement); }
}

/**
 * Parse an expression.
 *
 * <pre>
 *   expression ::= {LPAREN}+ expression {RPAREN}+ //TODO create parenthesizedExpression instead
 *                  | nestConExpression
 *                  | nestDecAnonym
 *                  | monOp expression
 *                  | expression POSTINC
 *                  | expression POSTDEC
 *                  | expression pointOp expression
 *                  | expression arithOpFirst expression
 *                  | expression arithOpSecond expression
 *                  | expression arithOpThird expression
 *                  | expression consBinOp expression
 *                  | expression evalBinOp expression
 *                  | DOLLAR
 *                  | term
 *                  | THIS
 *                  | {LCURLY}+ expression {expression} {RCURLY}+ //TODO create curledExpression instead
 * </pre>
 *
 * @return an AST for an expression.
 */
private Expression expression(): {
    int line = 0;
    Expression expression = null;
    Expression expression2 = null;
    Operator operator = null;
}
{
    try {
          expression = nestConExpression() { line = token.beginLine; }
        | expression = nestDecAnonym() { line = token.beginLine; }
        | operator = monOp() { line = token.beginLine; }
          expression = expression()
          { expression = new MonOpExpression(line, operator, expression); }
        | expression = expression() { line = token.beginLine; }
          (
            <POSTINC> { expression = new PostFixExpression(line, expression, "++"); }
            | <POSTDEC> { expression = new PostFixExpression(line, expression, "--"); }
          )
        | expression = expression() { line = token.beginLine; }
          (
            operator = pointOp()
            expression2 = expression()
            { expression = new SelectorExpression(line, expression, expression2); } |
            (
              operator = arithOpFirst() |
              operator = arithOpSecond() |
              operator = arithOpThird() |
              operator = consBinOp() |
              operator = evalBinOp()
            )
            expression2 = expression()
            { expression = new BinaryExpression(line, expression, expression2); }
          )
        | <DOLLAR>
          { line = token.beginLine;
            expression = new AnonymExpression(line); }
        | expression = term()
        | <THIS>
          { line = token.beginLine;
            expression = new ThisExpression(line); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{EOF}, e);
    }
    { return expression; }
}

/**
 * Parse an inStatement, that is a/multiple statement/s included in a block.
 *
 * <pre>
 *   inStatement ::= LCURLY {declarationPart} {statement}+ RCURLY
 *                    | LCURLY {declarationPart} expression RCURLY
 * </pre>
 *
 * @return an AST for an inStatement.
 */
private InStatement inStatement(): {
    int line = 0;
    DeclarationPart aDecl = null;
    ArrayList<DeclarationPart> decls = new ArrayList<>();
    Statement aStatement = null;
    ArrayList<Statement> statements = new ArrayList<>();
    Expression expression = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        (
          aDecl = declarationPart() { decls.add(aDecl); }
        )*
        (
          (
            aStatement = statement() { statements.add(aStatement); }
          )*
          |
          expression = expression()
        )
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new InStatement(line, decls, statements, expression); }
}

/**
 * Parse an inExpression, that is an expression included in a block.
 *
 * <pre>
 *   inExpression ::= LCURLY {declarationPart} [statement] expression RCURLY
 *                    | LCURLY {declarationPart} statement RCURLY
 * </pre>
 *
 * @return an AST for an inExpression.
 */
private InExpression inExpression(): {
    int line = 0;
    DeclarationPart aDecl = null;
    ArrayList<DeclarationPart> decls = new ArrayList<>();
    Statement statement = null;
    Expression expression = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        (
          aDecl = declarationPart() { decls.add(aDecl); }
        )*
        statement = statement()
        [
          expression = expression()
        ]
        <RCURLY>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return new InExpression(line, decls, statement, expression); }
}

/**
 * Parse a nestable construct (statement).
 *
 * <pre>
 *   nestConStatement ::= expression (ASSIGN|DEFINE) expression
 *                    | variable LPAREN {expresseion {COMMA expression}} RPAREN
 *                    | {LCURLY}+ expression {expression} {RCURLY}+ //TODO create curledExpression instead
 *                    | LPAREN inStatement RPAREN
 *                    | IF LPAREN expression RPAREN inStatement
 *                      {ELSE IF LPAREN expression RPAREN inStatement}
 *                      [ELSE inStatement]
 *                    | MATCH expression LCURLY
 *                      {CASE caseStatementClause}+
 *                      [ELSE inStatement]
 *                      RCURLY
 *                    | FOR LPAREN {loopDec}+ RPAREN inStatement //TODO how could we have mult loopDecs ?
 *                    | TRY inStatement
 *                      [CATCH LCURLY
 *                      {CASE caseStatementClause}+
 *                      RCURLY]
 *                      [FINALLY inStatement]
 *                    | RAISE inExpression
 *                    | THREAD inStatement
 *                    | LOCK [LPAREN expression RPAREN] inStatement
 * </pre>
 *
 * @return an AST for a nestConStatement.
 */
private Statement nestConStatement(): {
    int line = 0;
    Statement out = null;
    Variable name = null;
    Statement statement = null;
    Statement statement2 = null;
    Expression expression = null;
    Expression expression2 = null;
    ArrayList<Expression> args = new ArrayList<>();
    ArrayList<Expression> conds = new ArrayList<>();
    ArrayList<InStatement> consq = new ArrayList<>();
    CaseStatementClause aClause = null;
    ArrayList<CaseStatementClause> clauses = new ArrayList<>();
    LoopDeclaration loopDec = null;
}
{
    try {
        expression = expression() { line = token.beginLine; }
         (
          <ASSIGN> expression2 = expression()
          { out = new AssignStatement(line, expression, expression2, "assign"); }
          | <DEFINE> expression2 = expression()
          { out = new AssignStatement(line, expression, expression2, "define"); }
         )
        | name = variable() { line = token.beginLine; }
          <LPAREN> expression2 = expression() { args.add(expression2); }
          (
            <COMMA> expression2 = expression() { args.add(expression2); }
          )* <RPAREN>
          { out = new Call(line, name, args, "procedure"); }
        | <LPAREN> { line = token.beginLine; } statement = inStatement() <RPAREN>
          { out = statement; }
        | <IF> { line = token.beginLine; }
          <LPAREN> expression = expression() <RPAREN> statement = inStatement()
          { conds.add(expression); consq.add(statement); }
          (
            <ELSE> <IF> <LPAREN> expression = expression() <RPAREN> statement = inStatement()
            { conds.add(expression); consq.add(statement); }
          )*
          [
            <ELSE> statement = inStatement()
            { consq.add(statement); }
          ]
          { out = new ConditionalStruct(line, conds, consq); }
        | <MATCH> { line = token.beginLine; }
          expression = expression() <LCURLY>
          (
            <CASE> aClause = caseStatementClause() { clauses.add(aClause); }
          )+
          <ELSE> statement = inStatement() <RCURLY>
          { out = new CaseStructure(line, expression, clauses, statement); }
        | <FOR> { line = token.beginLine; }
          <LPAREN> loopDec = loopDeclaration() <RPAREN> statement = inStatement()
          { out = new LoopStructure(line, loopDec, statement); }
        | <TRY> { line = token.beginLine; }
          statement = inStatement()
          [
            <CATCH> <LCURLY>
            (
              <CASE> aClause = caseStatementClause() { clauses.add(aClause); }
            )+ <RCURLY>
          ]
          [
            <FINALLY> statement2 = inStatement()
          ]
          { out = new TryStructure(line, statement, clauses, statement2); }
        | <RAISE> { line = token.beginLine; }
          expression = inExpression()
          { out = new RaiseStructure(line, expression); }
        | <THREAD> { line = token.beginLine; }
          statement = inStatement()
          { out = new ThreadStructure(line, statement); }
        | <LOCK> { line = token.beginLine; }
          [
            <LPAREN> expression = expression() <RPAREN>
          ]
          statement = inStatement()
          { out = new LockStructure(line, expression, statement); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable construct (expression).
 *
 * <pre>
 *   nestConExpression ::= variable LPAREN {expresseion {COMMA expression}} RPAREN
 *                    | LPAREN expression RPAREN
 *                    | IF LPAREN expression RPAREN inExpression
 *                      {ELSE IF LPAREN expression RPAREN inExpression}
 *                      [ELSE inExpression]
 *                    | MATCH expression LCURLY
 *                      {CASE caseExpressionClause}+
 *                      [ELSE inExpression]
 *                      RCURLY
 *                    | FOR LPAREN {loopDec}+ RPAREN inExpression //TODO how could we have mult loopDecs ?
 *                    | TRY inExpression
 *                      [CATCH LCURLY
 *                      {CASE caseExpressionClause}+
 *                      RCURLY]
 *                      [FINALLY inStatement]
 *                    | RAISE inExpression
 *                    | THREAD inExpression
 *                    | LOCK [LPAREN expression RPAREN] inExpression
 * </pre>
 *
 * @return an AST for a nestConExpression.
 */
private Expression nestConExpression(): {
    int line = 0;
    Statement out = null;
    Variable name = null;
    Statement statement = null;
    Statement statement2 = null;
    Expression expression = null;
    Expression expression2 = null;
    ArrayList<Expression> args = new ArrayList<>();
    ArrayList<Expression> conds = new ArrayList<>();
    ArrayList<InStatement> consq = new ArrayList<>();
    CaseStatementClause aClause = null;
    ArrayList<CaseStatementClause> clauses = new ArrayList<>();
    LoopDeclaration loopDec = null;
}
{
    try {
        name = variable() { line = token.beginLine; }
          <LPAREN> expression2 = expression() { args.add(expression2); }
          (
            <COMMA> expression2 = expression() { args.add(expression2); }
          )* <RPAREN>
          { out = new Call(line, name, args, "function"); }
        | <LPAREN> { line = token.beginLine; } expression = expression() <RPAREN>
          { out = statement; }
        | <IF> { line = token.beginLine; }
          <LPAREN> expression = expression() <RPAREN> expression2 = inExpression()
          { conds.add(expression); consq.add(expression2); }
          (
            <ELSE> <IF> <LPAREN> expression = expression() <RPAREN> expression2 = inExpression()
            { conds.add(expression); consq.add(expression2); }
          )*
          [
            <ELSE> expression = inExpression()
            { consq.add(expression); }
          ]
          { out = new ConditionalStruct(line, conds, consq); }
        | <MATCH> { line = token.beginLine; }
          expression = expression() <LCURLY>
          (
            <CASE> aClause = caseExpressionClause() { clauses.add(aClause); }
          )+
          <ELSE> expression2 = inExpression() <RCURLY>
          { out = new CaseStructure(line, expression, clauses, expression2); }
        | <FOR> { line = token.beginLine; }
          <LPAREN> loopDec = loopDeclaration() <RPAREN> expression = inExpression()
          { out = new LoopStructure(line, loopDec, expression); }
        | <TRY> { line = token.beginLine; }
          expression = inExpression()
          [
            <CATCH> <LCURLY>
            (
              <CASE> aClause = caseExpressionClause() { clauses.add(aClause); }
            )+ <RCURLY>
          ]
          [
            <FINALLY> statement = inStatement()
          ]
          { out = new TryStructure(line, expression, clauses, statement); }
        | <RAISE> { line = token.beginLine; }
          expression = inExpression()
          { out = new RaiseStructure(line, expression); }
        | <THREAD> { line = token.beginLine; }
          expression = inExpression()
          { out = new ThreadStructure(line, expression); }
        | <LOCK> { line = token.beginLine; }
          [
            <LPAREN> expression = expression() <RPAREN>
          ]
          expression2 = inExpression()
          { out = new LockStructure(line, expression, expression2); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable declaration (variables).
 *
 * <pre>
 *   nestDecVariable ::= DEFPROC variable LPAREN {pattern {COMMA pattern}} RPAREN inStatement
 *                 | DEF [LAZY] variable LPAREN {pattern {COMMA pattern}} RPAREN inExpression
 *                 | FUNCTOR [variable] {
 *                     [IMPORT {variable [AT atom]
 *                             | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
 *                           }+]
 *                     [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
 *                   }
 *                   inStatement
 *                 | CLASS variable {classDescriptor} LCURLY
 *                   {DEF methHead [ASSIGN variable] (inExpression|inStatement)} RCURLY
 * </pre>
 *
 * @return an AST for a nestDecVariable.
 */
private Statement nestDecVariable(): {
    int line = 0;
    int line2 = 0;
    Statement out = null;
    Statement statement = null;
    Expression expression = null;
    Variable name = null;
    Variable name2 = null;
    boolean lazy = false;
    Pattern aPattern = null;
    ArrayList<Pattern> args = new ArrayList<>();
    ArrayList<> imports = new ArrayList<>();
    ArrayList<> exports = new ArrayList<>();
    ClassDescriptor aDescriptor = null;
    ArrayList<ClassDescriptor> descriptors = new ArrayList<>();
    MethodHead aMethodHead = null;
    ArrayList<Method> methods = new ArrayList<>();
}
{
    try {
        <DEFPROC> { line = token.beginLine; }
          name = variable() <LPAREN>
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )* <RPAREN>
          statement = inStatement()
          { out = new ProcedureDef(line, name, args, statement); }
        | <DEF> { line = token.beginLine; }
          [<LAZY> { lazy = true; }]
          name = variable() <LPAREN>
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )* <RPAREN>
          expression = inExpression()
          { out = new FunctionDef(line, name, args, expression, lazy); }
        | <FUNCTOR> { line = token.beginLine; }
          [ name = variable() ]
          (
            [ <IMPORT>
              (
                  //TODO create an new object for this ?
                  //TODO add it to list imports
              )* ]
            [ <EXPORT>
              (
                  //TODO create an new object for this ?
                  //TODO add it to list exports
              )* ]
          )*
          statement = inStatement()
          { out = new Functor(line, name, imports, exports, statement); }
        | <CLASS> { line = token.beginLine; }
          name = variable()
          (
            aDescriptor = classDescriptor() { descriptors.add(aDescriptor); }
          )* <LCURLY>
          (
            <DEF> { line2 = token.beginLine; }
            aMethodHead = methHead()
            [<ASSIGN> name2 = variable()]
            (
              expression = inExpression() |
              statement = inStatement()
            )
            { methods.add(new Method(line2, aMethodHead, name2, expression, statement)); }
          )* <RCURLY>
          { out = new ClassDeclaration(line, name, descriptors, methods); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a nestable declaration (anonymous).
 *
 * <pre>
 *   nestDecAnonym ::= DEFPROC DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inStatement
 *                 | DEF [LAZY] DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inExpression
 *                 | FUNCTOR [variable] {
 *                     [IMPORT {variable [AT atom]
 *                             | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
 *                           }+]
 *                     [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
 *                   }
 *                   inStatement
 *                 | CLASS DOLLAR {classDescriptor} LCURLY
 *                   {DEF methHead [ASSIGN variable] (inExpression|inStatement)} RCURLY
 * </pre>
 *
 * @return an AST for a nestDecAnonym.
 */
private Statement nestDecAnonym(): {
    int line = 0;
    int line2 = 0;
    Statement out = null;
    Statement statement = null;
    Expression expression = null;
    Variable name = null;
    boolean lazy = false;
    Pattern aPattern = null;
    ArrayList<Pattern> args = new ArrayList<>();
    ArrayList<> imports = new ArrayList<>();
    ArrayList<> exports = new ArrayList<>();
    ClassDescriptor aDescriptor = null;
    ArrayList<ClassDescriptor> descriptors = new ArrayList<>();
    MethodHead aMethodHead = null;
    ArrayList<Method> methods = new ArrayList<>();
}
{
    try {
        <DEFPROC> { line = token.beginLine; }
          <DOLLAR> <LPAREN>
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )* <RPAREN>
          statement = inStatement()
          { out = new ProcedureDef(line, null, args, statement); }
        | <DEF> { line = token.beginLine; }
          [<LAZY> { lazy = true; }]
          <DOLLAR> <LPAREN>
          aPattern = pattern() { args.add(aPattern); }
          (
            <COMMA> aPattern = pattern() { args.add(aPattern); }
          )* <RPAREN>
          expression = inExpression()
          { out = new FunctionDef(line, null, args, expression, lazy); }
        | <FUNCTOR> { line = token.beginLine; }
          [ name = variable() ]
          (
            [ <IMPORT>
              (
                  //TODO create an new object for this ?
                  //TODO add it to list imports
              )* ]
            [ <EXPORT>
              (
                  //TODO create an new object for this ?
                  //TODO add it to list exports
              )* ]
          )*
          statement = inStatement()
          { out = new Functor(line, name, imports, exports, statement); }
        | <CLASS> { line = token.beginLine; }
          <DOLLAR>
          (
            aDescriptor = classDescriptor() { descriptors.add(aDescriptor); }
          )* <LCURLY>
          (
            <DEF> { line2 = token.beginLine; }
            aMethodHead = methHead()
            [<ASSIGN> name = variable()]
            (
              expression = inExpression() |
              statement = inStatement()
            )
            { methods.add(new Method(line2, aMethodHead, name, expression, statement)); }
          )* <RCURLY>
          { out = new ClassDeclaration(line, null, descriptors, methods); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a case/match statement clause.
 *
 * <pre>
 *   caseStatementClause ::= pattern {logicOp expression} IMPL inStatement
 * </pre>

 * @return an AST for a caseStatementClause.
 */
private CaseStatementClause caseStatementClause(): {
    int line = 0;
    Statement statement = null;
    Pattern pattern = null;
    LogicOp logicOp = null;
    ArrayList<LogicOp> ops = new ArrayList<>();
    Expression expression = null;
    ArrayList<Expression> exprs = new ArrayList<>();
}
{
    try {
        pattern = pattern() { line = token.beginLine; }
        (
          logicOp = logicOp()
          expression = expression()
          { ops.add(logicOp); exprs.add(expression); }
        )*
        <IMPL> statement = inStatement()
        { out = new CaseStatementClause(line, pattern, ops, exprs, statement); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a case/match expression clause.
 *
 * <pre>
 *   caseExpressionClause ::= pattern {logicOp expression} IMPL inExpression
 * </pre>

 * @return an AST for a caseExpressionClause.
 */
private CaseExpressionClause caseExpressionClause(): {
    int line = 0;
    Statement expression = null;
    Pattern pattern = null;
    LogicOp logicOp = null;
    ArrayList<LogicOp> ops = new ArrayList<>();
    Expression aExpression = null;
    ArrayList<Expression> exprs = new ArrayList<>();
}
{
    try {
        pattern = pattern() { line = token.beginLine; }
        (
          logicOp = logicOp()
          aExpression = expression()
          { ops.add(logicOp); exprs.add(aExpression); }
        )*
        <IMPL> expression = inExpression()
        { out = new CaseExpressionClause(line, pattern, ops, exprs, expression); }
    }
    catch ( ParseException e ) {
       recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a term.
 *
 * <pre>
 *   term ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL
 *            | atomLisp LPAREN [[feature COLON]expression {COMMA [feature COLON]expression}] RPAREN
 *            | variable LPAREN [expression {COMMA expression}] RPAREN
 *            | LBRACK [expression {COMMA expression}] RBRACK
 * </pre>

 * @return an AST for a term.
 */
private Expression term(): {
    int line = 0;
    int lostLabelsCounter = 1;
    Expression out = null;
    boolean bool = true;
    Expression value = null;
    Feature aFeature = null;
    Expression val = null;
    Map<Feature, Expression> map = new HashMap<>();
    ArrayList<Expression> args = new ArrayList<>();
}
{
    try {
        <UNIT> { out = new Term(token.beginLine, Term.UNIT); }
        | <TRUE> { out = new Term(token.beginLine, Term.BOOLEAN, true); }
        | <FALSE> { out = new Term(token.beginLine, Term.BOOLEAN, false); }
        | <UNDERSCORE> { out = new Term(token.beginLine, Term.UNDERSCORE); }
        | <NIL> { out = new Term(token.beginLine, Term.NIL); }
        | value = integer() { out = new Term(token.beginLine, Term.INT, value); }
        | value = floating() { out = new Term(token.beginLine, Term.FLOAT, value); }
        | value = character() { out = new Term(token.beginLine, Term.CHAR, value); }
        | value = atom() {out = new Term(token.beginLine, Term.ATOM, value); }
        | value = string() { out = new Term(token.beginLine, Term.STRING, value); }
        | (
          <LNOT> {bool = !bool; }
          )*
          value = variable() { line = token.beginLine;
          out = new Term(line, Term.UNKNOWN, value, bool); } //TODO if bool is false, we must ensure type is BOOLEAN
        | value = atomLisp() { line = token.beginLine; } //This is a record
          <LPAREN> [
          [ aFeature = feature() <COLON> { map.put(aFeature, null); }]
          val = expression()
          { if(aFeature==null){
              map.put(labelCounter, val);
              lostLabelsCounter++;
            } else {
              map.put(aFeature, val);
            }}
          (
            <COMMA>
            [aFeature = feature() <COLON> { map.put(aFeature, null); }]
            val = expression()
            { if(aFeature==null){
                map.put(labelCounter, val);
                lostLabelsCounter++;
              } else {
                map.put(aFeature, val);
              }}
          )* ] <RPAREN>
          { out = new Record(line, value, map); }
        | value = variable() { line = token.beginLine; } //This is a function call
          <LPAREN> [
          val = expression() { args.add(val); }
          (
            <COMMA>
            val = expression() { args.add(val); }
          )* ] <RPAREN>
          { out = new Call(line, value, args, "function"); }
        | <LBRACK> { line = token.beginLine; }
          [
            val = expression() { args.add(val); }
            (
              <COMMA> val = expression() { args.add(val); }
            )*
          ]
          { out = new ListInit(line, args); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return statement; }
}

/**
/**
 * Parse a pattern.
 *
 * <pre>
 *   pattern ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL
 *            | atomLisp LPAREN [[feature COLON]pattern {COMMA [feature COLON]pattern} [COMMA ELLIPSIS]] RPAREN
 *            | LPAREN pattern consBinOp pattern RPAREN
 *            | LBRACK [pattern {COMMA pattern}] RBRACK
 *            | LPAREN pattern RPAREN
 * </pre>

 * @return an AST for a term.
 */
private Pattern pattern(): {
    int line = 0;
    int lostLabelsCounter = 1;
    Pattern out = null;
    boolean bool = true;
    Expression value = null;
    Feature aFeature = null;
    Expression val = null;
    Map<Feature, Pattern> map = new HashMap<>();
    bool more = false;
    Pattern pat1 = null;
    Operator op = null;
    Pattern pat2 = null;
    ArrayList<Pattern> patterns = new ArrayList<>();
}
{
    try {
        <UNIT> { out = new Term(token.beginLine, Term.UNIT); }
        | <TRUE> { out = new Term(token.beginLine, Term.BOOLEAN, true); }
        | <FALSE> { out = new Term(token.beginLine, Term.BOOLEAN, false); }
        | <UNDERSCORE> { out = new Term(token.beginLine, Term.UNDERSCORE); }
        | <NIL> { out = new Term(token.beginLine, Term.NIL); }
        | value = integer() { out = new Term(token.beginLine, Term.INT, value); }
        | value = floating() { out = new Term(token.beginLine, Term.FLOAT, value); }
        | value = character() { out = new Term(token.beginLine, Term.CHAR, value); }
        | value = atom() {out = new Term(token.beginLine, Term.ATOM, value); }
        | value = string() { out = new Term(token.beginLine, Term.STRING, value); }
        | (
          <LNOT> {bool = !bool; }
          )*
          value = variable() { line = token.beginLine;
          out = new Term(line, Term.UNKNOWN, value, bool); } //TODO if bool is false, we must ensure type is BOOLEAN
        | value = atomLisp() { line = token.beginLine; } //This is a pattern record
           <LPAREN> [
           [ aFeature = feature() <COLON> { map.put(aFeature, null); }]
           val = pattern()
           { if(aFeature==null){
               map.put(labelCounter, val);
               lostLabelsCounter++;
             } else {
               map.put(aFeature, val);
             }}
           (
             <COMMA>
             [aFeature = feature() <COLON> { map.put(aFeature, null); }]
             val = pattern()
             { if(aFeature==null){
                 map.put(labelCounter, val);
                 lostLabelsCounter++;
               } else {
                 map.put(aFeature, val);
               }}
           )*
           [<COMMA> <ELLIPSIS> { more = true; }]
           ] <RPAREN>
           { out = new PatternRecord(line, value, map, more); }
        | <LPAREN> { line = token.beginLine; }
          pat1 = pattern()
          op = consBinOp()
          pat2 = pattern() <RPAREN>
          { out = new PatternUnion(pat1, pat2, op); }
        | <LBRACK> { line = token.beginLine; }
          [
            pat1 = pattern() { patterns.add(pat1); }
            (
              <COMMA>
              pat1 = pattern() { patterns.add(pat1); }
            )*
          ] <RBRACK>
          { out = new PatternListInit(line, patterns); }
        | <LPAREN> { line = token.beginLine; }
          pat1 = pattern() { out = pat1; }
          <RPAREN>
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a variables declaration group.
 *
 * <pre>
 *   declarationPart ::= (VAL|VAR) (variable|pattern) ASSIGN (expression|statement) //TODO why statement ?
 *                        {COMMA (variable|pattern) ASSIGN (expression|statement)} //TODO why pattern ?
 * </pre>
 *
 * @return an AST for a declarationPart.
 */
private DeclarationPart declarationPart(): {
    int line = 0;
    boolean constant;
    DeclarationPart out = null;
    Variable variable = null;
    Expression value = null;
    Map<Variable, Expression> map = new HashMap<>();
}
{
    try {
        (
          <VAL> { line = token.beginLine; constant = true; }
        | <VAR> { line = token.beginLine; constant = false; }
        )
        variable = variable() <ASSIGN> value = expression()
        { map.put(variable, value); }
        (
          <COMMA> variable = variable() <ASSIGN> value = expression()
          { map.put(variable, value); }
        )*
        { out = new DeclarationPart(line, map, constant); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}

/**
 * Parse a loop declaration.
 *
 * <pre>
 *   loopDec ::= variable IN expression [DOTDOT expression] [SEMI expression]
 *                | variable IN expression SEMI expression SEMI expression
 *                | BREAK COLON variable
 *                | CONTINUE COLON variable
 *                | RETURN COLON variable
 *                | DEFLT COLON expression
 *                | COLLECT COLON variable
 * </pre>
 *
 * @return an AST for a loop declaration.
 */
private LoopDeclaration loopDeclaration(): {
    int line = 0;
}
{
    try {
    }
    catch ( ParseException e ) {
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return out; }
}

/**
 * Parse a point operator.
 *
 * <pre>
 *   pointOp ::= DOT
 * </pre>
 *
 * @return an AST for a loop declaration.
 */
private Operator pointOp(): {
    int line = 0;
    Operator out = null;
}
{
    try {
        <DOT> { out = new Operator(token.beginLine, Operator.DOT); }
    }
    catch ( ParseException e ) {
        recoverFromError(new int[]{RCURLY}, e);
    }
    { return out; }
}







/**
 * Parse a literal.
 *
 * <pre>
 *   literal ::= INT_LITERAL | FLOAT | CHAR | STRING
 *             | TRUE        | FALSE        | NULL
 * </pre>
 *
 * @return an AST for a literal.
 */
private Expression literal(): {
    Expression expr = null;
}
{
    try {
        <INT_LITERAL>
        { expr = new LiteralInt( token.beginLine, token.image ); } |
        <CHAR>
        { expr = new LiteralChar( token.beginLine, token.image ); } |
        <STRING>
        { expr = new LiteralString( token.beginLine, token.image ); } |
        <TRUE>
        { expr = new LiteralTrue( token.beginLine ); } |
        <FALSE>
        { expr = new LiteralFalse( token.beginLine ); } |
        <UNIT>
        { expr = new LiteralUnit( token.beginLine ); } |
        <ATOM>
        { expr = new LiteralAtom( token.beginLine ); }
    }
    catch ( ParseException e ) {
        expr = new WildExpression( token.beginLine );
        recoverFromError( new int[] { RCURLY, EOF }, e );
    }
    { return expr; }
}