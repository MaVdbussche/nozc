// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

// This is the input file to JavaCC for generating a scanner and
// a parser for newOz. From the specification in this file, JavaCC,
// among other files, generates a JavaCCParser.java file
// under this directory. This file is the parser. The code
// between  PARSER_BEGIN( JavaCCParser ) and
// PARSER_END( JavaCCParser ) is copied verbatim to this file. JavaCC
// also generates a JavaCCParserTokenManager.java file which is the
// scanner.

PARSER_BEGIN( JavaCCParser )

package jminusminus;

import java.util.ArrayList;

/**
 * Parser generated by JavaCC. It parses a newOz compilation block
 * (program file), taking tokens from the scanner (also generated by
 * JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;

    /** Name of the file that is parsed. */
    private String fileName;

    /**
     * Pull out the ambiguous part of a name and return it.
     *
     * @param name with an ambiguous part (possibly).
     * @return ambiguous part or null.
     */
    private AmbiguousName ambiguousPart(TypeName name) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf('.');
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName(name.line(), qualifiedName.substring( 0, lastDotIndex));
    }

    /**
     * Report a syntax error.
     *
     * @param message message identifying the error.
     * @param args related values.
     */
    private void reportParserError(String message, Object... args) {
        errorHasOccurred = true;
        System.err.printf("%s:%d: ", fileName, token.beginLine);
        System.err.printf(message, args);
        System.err.println();
    }

    /**
     * Recover from the parser error that occurred by skipping to
     * any of the specified tokens.
     *
     * Current error recovery mechanism is rather simple-minded and is
     * based on skipping all the tokens until a SEMI or an EOF is
     * encountered. This scheme can be enhanced by passing in the
     * FOLLOW-SET of the non-terminal at hand.
     *
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event
     * of a parser error.
     */
    private void recoverFromError(int[] skipTo, ParseException e) {
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[ i ].length; j++) {
                expected.append("\n");
                expected.append("\t");
                expected.append(tokenImage[e.expectedTokenSequences[i][j]]);
                expected.append("...");
            }
        }

        // Print error message
        if (e.expectedTokenSequences.length == 1) {
            reportParserError("\"%s\" found where %s sought", getToken( 1 ), expected);
        } else {
            reportParserError("\"%s\" found where one of %s sought", getToken(1), expected);
        }

        // Recover
        boolean loop = true;
        do {
            token = getNextToken();
            for (int i : skipTo) {
                if (token.kind == i) {
                    loop = false;
                    break;
                }
            }
        } while(loop);
    }

    /**
     * Set the name of the file that is being parsed.
     *
     * @param fileName name of the file.
     */
    public void fileName(String fileName) {
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     *
     * @return true or false.
     */
    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The newOz lexical grammar starts here       //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"}

// Single-line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Multi-line comment -- ignored
SKIP: {<"/*"> : MULTI_COMMENT}
<MULTI_COMMENT>
SKIP : {<"*/"> : DEFAULT | < ~[] >}

// Reserved words
TOKEN : {
  < AT: "at" >
| < ATTR: "attr" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHOICE: "choice" > //TODO What's this ?
| < CLASS: "class" >
| < COLLECT: "collect" > //TODO What's this ?
| < COND: "cond" > //TODO What's this ?
| < CONTINUE: "continue" >
| < DECLARE: "declare" >
| < DEF: "def" >
| < DEFPROC: "defproc" >
| < DEFLT: "default" >
| < DIS: "dis" > //TODO What's this ?
| < DO: "do" >
| < ELSE: "else" >
//| < ELSECASE: "elsecase" > TODO ?
//| < ELSEOF: "elseof" > TODO ?
| < EXPORT: "export" >
| < FAIL: "fail" > //TODO What's this ?
| < FALSE: "false" >
| < FEAT: "feat" > //TODO What's this ?
| < FINALLY: "finally" >
| < FOR: "for" >
| < FROM: "from" >
| < FUNCTOR: "functor" >
| < IF: "if" >
| < IMPORT: "import" >
| < IN: "in" >
| < LAZY: "lazy" >
| < LOCK: "lock" >
| < MATCH: "match" >
| < METH: "meth" >
| < NOT: "not" > //TODO What's this ?
| < OF: "of" >
| < OR: "or" >
| < PREPARE: "prepare" > //TODO What's this ?
| < PROP: "prop" > //TODO What's this ?
| < RAISE: "raise" >
| < REQUIRE: "require" > //TODO What's this ?
| < RETURN: "return" >
| < SKP: "skip" >
| < THIS: "this" >
| < THREAD: "thread" >
| < TRUE: "true" >
| < TRY: "try" >
| < UNIT: "unit" >
| < VAL: "val" >
| < VAR: "var" >
}

// Operators
TOKEN : {
  <ASSIGN: "=">
| <DEFINE: ":=">
| <EQUAL: "==">
| <NE: "\\=">
| <LT: "<">
| <GT: ">">
| <LE: "=<">
| <GE: ">=">
| <LBARROW: "<=">
| <IMPL: "=>">
| <AND: "&"> //TODO DELETED
| <LAND: "&&">
| <PIPE: "|"> //TODO DELETED
| <LOR: "||">
| <LNOT: "!">
| <LNOTNOT: "!!">
| <MINUS: "-">
| <PLUS: "+">
| <STAR: "*">
| <SLASH: "/">
| <BACKSLASH: "\\">
| <MODULO: "%">
| <HASHTAG: "#">
| <UNDERSCORE: "_">
| <DOLLAR: "$">
| <APOSTROPHE: "'">
| <QUOTE: "\"">
| <LACCENT: "`">
| <RACCENT: "´">
| <HAT: "^">
| <BOX: "[]">
| <TILDE: "~">
| <DEGREE: "°">
| <COMMERCAT: "@">
| <LARROW: "<-">
| <RARROW: "->">
| <FDASSIGN: "=:">
| <FDNE: "\\=:">
| <FDLT: "<:">
| <FDLE: "=<:">
| <FDGT: ">:">
| <FDGE: ">=:">
| <COLCOL: "::">
| <COLCOLCOL: ":::">
}

// Separators
TOKEN : {
 <COMMA: ",">
| <LBRACK: "[">
| <LCURLY: "{">
| <LPAREN: "(">
| <RBRACK: "]">
| <RCURLY: "}">
| <RPAREN: ")">
| <SEMI: ";">
| <COLON: ":">
| <DOT: ".">
| <DOTDOT: "..">
| <ELLIPSIS: "...">
}

// Identifiers
TOKEN : {
 < IDENTIFIER: (<LETTER>|"_") (<LETTER>|<DIGIT>|"_")* >
| < #LETTER: ["a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
} //TODO probably more

// Literals
// TODO lot of reflexion neede here

// For anything else, we return an ERROR token. Without this
// definition the TokenManager will throw an Error when a lexical
// error occurs, making it impossible to recover from it. So we
// define this ERROR token.
TOKEN:
{
 < ERROR: ~[] >
}