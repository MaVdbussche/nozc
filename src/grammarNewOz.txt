// EBNF grammar for newOz, suitable for recursive descent
// This is translated directly from M. Mbonyincungu's thesis
// Note that the concatenation symbol in EBNF (comma) is omitted for readability reasons
// <T> represents a generic definition (think about Java generic types)
//Notation      Meaning
//========================================================================
//\epsilon      singleton containing the empty word
//(w)           grouping of regular expressions
//[ w ]         optional group
//{ w }         zero or more times w
//{ w }+        one or more times w
//w_1 w_2       concatenation of w_1 with w_2
//w_1 | w_2     logical union of w_1 and w_2 (OR)
//w_1 - w_2     difference of w_1 and w_2

// Interactive statements
interStatement ::= statement
                  | DECLARE LCURLY {declarationPart}+ [interStatement] RCURLY

statement ::= nestCon(statement)
            | nestDec(variable)
            | SKIP
            | statement statement //TODO left recursive !

expression ::= nestCon(expression)
            | nestDec(DOLLAR)
            | expressions evalBinOp expression
            | DOLLAR
            | term
            | monOp expression
            | THIS
            | UNDERSCORE

inStatement ::= {declarationPart} {statement}+

inExpression ::= {declarationPart} {statement} expression

in(statement) ::= inStatement

in(expression) ::= inExpression

// This is in the sense of the old Oz "in" keyword
blockIn(<T>) ::= LCURLY [(in(<T>)] RCURLY

//Here, <T> is statement or expression
nestCon(<T>) ::= expression (ASSIGN | DEFINE) expression
            | expression LPAREN {expression COMMA} RPAREN
            | blockIn(<T>)
            | LPAREN in(<T>) RPAREN
            | IF LPAREN expression RPAREN blockIn(<T>)
              {ELSE IF LPAREN expression RPAREN blockIn(<T>)}
              [ELSE blockIn(<T>)]
            | MATCH expression LCURLY {CASE pattern {logicOp expression} IMPL (blockIn(<T>) | in(<T>))}+
              [ELSE (blockIn(<T>) | in(<T>))] RCURLY
            | FOR LPAREN {loopDec}+ RPAREN blockIn(<T>)
            | TRY blockIn(<T>)
              [CATCH LCURLY {CASE pattern IMPL (blockIn(<T>) | in(<T>))}+ RCURLY]
              [FINALLY blockIn(<T>)]
            | RAISE blockIn(expression)
            | THREAD blockIn(<T>)
            | LOCK [LPAREN expression RPAREN] blockIn(<T>)

//Here, <T> is always DOLLAR or a variable
nestDec(T) ::= DEFPROC <T> LPAREN {pattern COMMA} RPAREN blockIn(statement)
            | DEF [LAZY] <T> LPAREN {pattern COMMA} RPAREN blockIn(expression)
            | FUNCTOR [<T>] {
                [IMPORT ({variable [AT atom]
                          | variable LPAREN {(atom | int) [COLON variable] COMMA}+ RPAREN) COMMA
                          }+]
                [EXPORT {[(atom | int) COLON] variable COMMA}+]
              }
              blockIn(statement)
            | CLASS <T> {classDescriptor} LCURLY
              {DEF methHead [ASSIGN variable] (blockIn(expression) | blockIn(statement))} RCURLY

// Terms and patterns
term ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE //TODO unit ??
      | label LPAREN {[feature COLON] expression COMMA} RPAREN
      | expression consBinOp expression //TODO left recursion
      | LBRACK {expression COMMA}+ RBRACK

pattern ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE //TODO unit ??
      | label LPAREN {[feature COLON] pattern COMMA} [COMMA ELLIPSIS] RPAREN
      | pattern consBinOp pattern //TODO left recursion
      | LBRACK {pattern}+ RBRACK

declarationPart ::= {(VAL | VAR) {(variable | pattern) ASSIGN (expression | statement) COMMA}+ [SEMI]}

loopDec ::= variable IN expression [DOTDOT expression] [SEMI expression]
        | variable IN expression SEMI expression SEMI expression
        | BREAK COLON variable
        | CONTINUE COLON variable
        | RETURN COLON variable
        | DEFAULT COLON expression
        | COLLECT COLON variable

binaryOp ::= evalBinOp | consBinOp

consBinOp ::= HASHTAG | COLCOL

evalBinOp ::= PLUS | MINUS | STAR | SLASH | MODULO | DOT
          | LAND | LOR | DEFINE | COMMA | ASSIGN | EQUAL
          | NE | LT | LE | GT | GE

monOp ::= PLUS | MINUS

logicOp ::= LAND | LOR

label ::= UNIT | TRUE | FALSE | variable | atom

feature ::= UNIT | TRUE | FALSE | variable | atom | int

classDescription ::= EXTENDS {expression}+
                  | PROP {expression}+
                  | ATTR {attrInit}+ //TODO what is this ?

attrInit ::= ([LNOT] variable | atom | UNIT | TRUE | FALSE) [COLON expression]

methHead ::= ([LNOT] variableStrict | atomLisp | UNIT | TRUE | FALSE)
              [LPAREN {methArg COMMA} [COMMA ELLIPSIS] RPAREN]
              [ASSIGN variable]

methArg ::= [feature COLON] (variable | UNDERSCORE | DOLLAR) [ASSIGN expression]

variableStrict ::= UPPERCASE {ALPHANUM}
              | APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE

variable ::= (UPPERCASE | LOWERCASE) {ALPHANUM}
          | APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE

atom ::= atomLisp
        | RACCENT {ATOMCHAR | PSEUDOCHAR} RACCENT

string ::= QUOTE {STRINGCHAR | PSEUDOCHAR} QUOTE

character ::= CHARINT
            | DEGREE CHARCHAR
            | DEGREE PSEUDOCHAR

atomLisp ::= APOSTROPHE (LOWERCASE | UPPERCASE) {alphanumericChar} - keywords //TODO