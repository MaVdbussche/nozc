// EBNF grammar for newOz, suitable for recursive descent
// This is translated directly from M. Mbonyincungu's thesis
// Note that the concatenation symbol in EBNF (comma) is omitted for readability reasons
// <T> represents a generic definition (think about Java generic types)
//Notation      Meaning
//========================================================================
//\epsilon      singleton containing the empty word
//(w)           grouping of regular expressions
//[ w ]         optional group
//{ w }         zero or more times w
//{ w }+        one or more times w
//w_1 w_2       concatenation of w_1 with w_2
//w_1 | w_2     logical union of w_1 and w_2 (OR)
//w_1 - w_2     difference of w_1 and w_2

// Interactive statements
interStatement ::= statement
                  | DECLARE LCURLY {declarationPart}+ [interStatement] RCURLY

statement ::= nestConStatement
            | nestDecVariable
            | SKIP
            | SEMI
            | statement SEMI statement
            | DECLARE statement

expression ::= {LPAREN}+ expression {RPAREN}+
            | nestConExpression
            | nestDecAnonym
            | monOp expression
            | expression POSTINC
            | expression POSTDEC
            | expression pointOp expression
            | expression arithOpFirst expression
            | expression arithOpSecond expression
            | expression arithOpThird expression
            | expression consBinOp expression
            | expressions evalBinOp expression
            | DOLLAR
            | term
            | THIS
            | {LCURLY}+ expression {expression} {RCURLY}+

inStatement ::= LCURLY {declarationPart} statement RCURLY
            | LCURLY {declarationPart} expression RCURLY

inExpression ::= LCURLY {declarationPart} [statement] expression RCURLY
            | LCURLY {declarationPart} statement RCURLY

nestConStatement ::= expression (ASSIGN|DEFINE) expression
            | expression LPAREN {expression {COMMA expression}} RPAREN
            | {LCURLY}+ expression {expression} {RCURLY}+
            | LPAREN inStatement RPAREN
            | IF LPAREN expression RPAREN inStatement
              {ELSE IF LPAREN expression RPAREN inStatement}
              [ELSE inStatement]
            | MATCH expression LCURLY
                {CASE caseStatementClause}+
                [ELSE inStatement]
              RCURLY
            | FOR LPAREN {loopDec}+ RPAREN inStatement
            | TRY inStatement
              [CATCH LCURLY
                {CASE caseStatementClause}+
              RCURLY]
              [FINALLY inStatement]
            | RAISE inExpression
            | THREAD inStatement
            | LOCK [LPAREN expression RPAREN] inStatement

nestConExpression ::= expression LPAREN {expression {COMMA expression}} RPAREN
            | LPAREN expression RPAREN
            | IF LPAREN expression RPAREN inExpression
                {ELSE IF LPAREN expression RPAREN inExpression}
                [ELSE inExpression]
            | MATCH expression LCURLY
               {CASE caseExpressionClause}+
               [ELSE inExpression]
              RCURLY
            | FOR LPAREN {loopDec}+ RPAREN inExpression
            | TRY inExpression
              [CATCH LCURLY
                {CASE caseExpressionClause}+
              RCURLY]
              [FINALLY inStatement]
            | RAISE inExpression
            | THREAD inExpression
            | LOCK [LPAREN expression RPAREN] inExpression

nestDecVariable ::= DEFPROC variable LPAREN {pattern {COMMA pattern}} RPAREN inStatement
            | DEF [LAZY] variable LPAREN {pattern {COMMA pattern}} RPAREN inExpression
            | FUNCTOR [variable] {
                [IMPORT {variable [AT atom]
                          | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
                          }+]
                [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
              }
              inStatement
            | CLASS variable {classDescriptor} LCURLY
              {DEF methHead [ASSIGN variable] (inExpression|inStatement)} RCURLY

//Here, <T> is always DOLLAR
nestDecAnonym ::= DEFPROC DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inStatement
            | DEF [LAZY] DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inExpression
            | FUNCTOR [DOLLAR] {
                [IMPORT {variable [AT atom]
                          | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
                          }+]
                [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
              }
              inStatement
            | CLASS DOLLAR {classDescriptor} LCURLY
              {DEF methHead [ASSIGN variable] (inExpression|inStatement)} RCURLY

caseStatementClause ::= pattern {logicOp expression} IMPL inStatement

caseExpressionClause ::= pattern {logicOp expression IMPL inExpression

// Terms and patterns
term ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL //TODO we can remove character bcs of int representation ?
      | label LPAREN {[feature COLON]expression {COMMA [feature COLON]expression}} RPAREN
      | LBRACK {expression {COMMA expression}} RBRACK

pattern ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL //TODO we can remove character bcs of int representation ?
      | label LPAREN {[feature COLON]pattern {COMMA [feature COLON]pattern}} [COMMA ELLIPSIS] RPAREN
      | pattern consBinOp pattern
      | LBRACK {pattern} RBRACK
      | {LPAREN pattern RPAREN}+

declarationPart ::= {(VAL|VAR) {(variable|pattern) ASSIGN (expression|statement) {COMMA (variable|pattern) ASSIGN (expression|statement)}}+} //TODO semicolon ?

loopDec ::= variable IN expression [DOTDOT expression] [SEMI expression]
        | variable IN expression SEMI expression SEMI expression
        | BREAK COLON variable
        | CONTINUE COLON variable
        | RETURN COLON variable
        | DEFLT COLON expression
        | COLLECT COLON variable

pointOp ::= DOT

monOp ::= LNOTNOT | RETURN

consBinOp ::= HASHTAG | COLCOL
//COLCOL replaces PIPE from OldOz

evalBinOp ::= LAND | LOR | DEFINE | COMMA | ASSIGN

logicOp ::= LAND | LOR

arithOpFirst ::= STAR | SLASH | MODULO | HAT | STARSTAR //TODO what is it ? Do we keep it in newOz ?

arithOpSecond ::= PLUS | MINUS

arithOpThird ::= EQUAL | NE | LT | LE | GT | GE

label ::= UNIT | TRUE | FALSE | variable | atom

feature ::= UNIT | TRUE | FALSE | variable | atom | int | NIL

classDescription ::= EXTENDS {expression}+
                  | PROP {expression}+
                  | ATTR {attrInit}+ //TODO what is this ?

attrInit ::= ([LNOT] variable | atom | UNIT | TRUE | FALSE) [COLON expression]

methHead ::= ([LNOT] variableStrict | atomLisp | UNIT | TRUE | FALSE)
              [LPAREN {methArg {COMMA methArg}} [COMMA ELLIPSIS] RPAREN]
              [ASSIGN variable]

methArg ::= [feature COLON] (variable | UNDERSCORE | DOLLAR) [ASSIGN expression]

variableStrict ::= UPPERCASE {ALPHANUM}
              | LACCENT {VARIABLECHAR | PSEUDOCHAR} LACCENT

variable ::= LOWERCASE{ALPHANUM}
          | APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE //TODO really ?

atom ::= atomLisp
        | RACCENT {ATOMCHAR | PSEUDOCHAR} RACCENT

atomLisp ::= APOSTROPHE (LOWERCASE | UPPERCASE) {ALPHANUM}

string ::= QUOTE {STRINGCHAR | PSEUDOCHAR} QUOTE

character ::= CHARINT
            | DEGREE CHARCHAR
            | DEGREE PSEUDOCHAR
            | CHAR // TODO in this case we should send a warning during analysis that it is not supported in underlying oldOz

int ::= [MINUS] DIGIT
        | [MINUS] NONZERODIGIT {DIGIT}
        | [MINUS] "0" {OCTDIGIT}+
        | [MINUS] ("0x"|"0X") {HEXDIGIT}+
        | [MINUS] ("0b"|"0B") {BINDIGIT}+

float ::= [MINUS] {DIGIT}+ DOT {DIGIT} [("e" | "E")[~]{DIGIT}+]