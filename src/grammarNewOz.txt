// EBNF grammar for newOz, suitable for recursive descent
// This is translated directly from M. Mbonyincungu's thesis
// Note that the concatenation symbol in EBNF (comma) is omitted for readability reasons
// <T> represents a generic definition (think about Java generic types)
//Notation      Meaning
//========================================================================
//\epsilon      singleton containing the empty word
//(w)           grouping of regular expressions
//[ w ]         optional group
//{ w }         zero or more times w
//{ w }+        one or more times w
//w_1 w_2       concatenation of w_1 with w_2
//w_1 | w_2     logical union of w_1 and w_2 (OR)
//w_1 - w_2     difference of w_1 and w_2

// Interactive statements [ENTRYPOINT]
interStatement ::= statement
                  | DECLARE LCURLY {declarationPart}+ [interStatement] RCURLY

statement ::= nestConStatement
            | nestDecVariable
            | SKIP
            | SEMI
            | statement SEMI statement
            | DECLARE statement

expression ::= nestConExpression
            | nestDecAnonym
            | monOp expression
            | expression POSTINC
            | expression POSTDEC
            | expression pointOp expression
            | expression arithOpFirst expression
            | expression arithOpSecond expression
            | expression arithOpThird expression
            | expression consBinOp expression
            | expression evalBinOp expression
            | DOLLAR
            | term
            | THIS
            | LCURLY expression {expression} RCURLY //TODO not implemented like this

inStatement ::= LCURLY {declarationPart} {statement} RCURLY //TODO added possibility for multiple chained statements
            | LCURLY {declarationPart} expression RCURLY

inExpression ::= LCURLY {declarationPart} [statement] expression RCURLY
            | LCURLY {declarationPart} statement RCURLY

nestConStatement ::= expression (ASSIGN|DEFINE) expression
            | expression LPAREN {expression {COMMA expression}} RPAREN
            | {LCURLY}+ expression {expression} {RCURLY}+
            | LPAREN inStatement RPAREN
            | IF LPAREN expression RPAREN inStatement
              {ELSE IF LPAREN expression RPAREN inStatement}
              [ELSE inStatement]
            | MATCH expression LCURLY
                {CASE caseStatementClause}+
                [ELSE inStatement]
              RCURLY
            | FOR LPAREN {loopDec}+ RPAREN inStatement
            | TRY inStatement
              [CATCH LCURLY
                {CASE caseStatementClause}+
              RCURLY]
              [FINALLY inStatement]
            | RAISE inExpression
            | THREAD inStatement
            | LOCK [LPAREN expression RPAREN] inStatement

nestConExpression ::= expression LPAREN {expression {COMMA expression}} RPAREN
            | LPAREN expression RPAREN
            | IF LPAREN expression RPAREN inExpression
                {ELSE IF LPAREN expression RPAREN inExpression}
                [ELSE inExpression]
            | MATCH expression LCURLY
               {CASE caseExpressionClause}+
               [ELSE inExpression]
              RCURLY
            | FOR LPAREN {loopDec}+ RPAREN inExpression
            | TRY inExpression
              [CATCH LCURLY
                {CASE caseExpressionClause}+
              RCURLY]
              [FINALLY inStatement]
            | RAISE inExpression
            | THREAD inExpression
            | LOCK [LPAREN expression RPAREN] inExpression

nestDecVariable ::= DEFPROC variable LPAREN {pattern {COMMA pattern}} RPAREN inStatement
            | DEF [LAZY] variable LPAREN {pattern {COMMA pattern}} RPAREN inExpression
            | FUNCTOR [variable] {
                [IMPORT {variable [AT atom]
                          | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
                        }+]
                [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
              }
              inStatement
            | CLASS variableStrict [classDescriptor] LCURLY
              {classElementDef} RCURLY

nestDecAnonym ::= DEFPROC DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inStatement
            | DEF [LAZY] DOLLAR LPAREN {pattern {COMMA pattern}} RPAREN inExpression
            | FUNCTOR [variable] {
                [IMPORT {variable [AT atom]
                          | variable LPAREN {(atom|int)[COLON variable] {COMMA (atom|int)[COLON variable]}}+ RPAREN
                          }+]
                [EXPORT {[(atom|int)COLON]variable {COMMA [(atom|int)COLON]variable}}+]
              }
              inStatement
            | CLASS DOLLAR [classDescriptor] LCURLY
              {classElementDef} RCURLY

classElementDef ::= DEF methHead [ASSIGN variable] (inExpression|inStatement)
                  | classDescriptor

caseStatementClause ::= pattern {logicOp expression} IMPL inStatement

caseExpressionClause ::= pattern {logicOp expression IMPL inExpression

// Terms and patterns
term ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL //TODO we can remove character bcs of int representation ?
      | atomLisp LPAREN [[feature COLON]expression {COMMA [feature COLON]expression}] RPAREN
      | variable LPAREN [expression {COMMA expression}] RPAREN
      | LBRACK [expression {COMMA expression}] RBRACK

pattern ::= {LNOT} variable | int | float | character | atom | string | UNIT | TRUE | FALSE | UNDERSCORE | NIL //TODO we can remove character bcs of int representation ?
      | atomLisp LPAREN [[feature COLON]pattern {COMMA [feature COLON]pattern} [COMMA ELLIPSIS]] RPAREN
      | LPAREN pattern consBinOp pattern RPAREN
      | LBRACK [pattern {COMMA pattern}] RBRACK
      | LPAREN pattern RPAREN

declarationPart ::= (VAL|VAR) (variable|pattern) ASSIGN (expression|statement) {COMMA (variable|pattern) ASSIGN (expression|statement)} //TODO why statement ?

loopDec ::= variable IN expression [DOTDOT expression] [SEMI expression]
        | variable IN expression SEMI expression SEMI expression
        | BREAK COLON variable
        | CONTINUE COLON variable
        | RETURN COLON variable
        | DEFLT COLON expression
        | COLLECT COLON variable

pointOp ::= DOT

monOp ::= LNOTNOT | RETURN | MINUS

consBinOp ::= HASHTAG | COLCOL
//COLCOL replaces PIPE from OldOz

evalBinOp ::= LAND | LOR | DEFINE | ASSIGN //| COMMA //TODO comma ?!

logicOp ::= LAND | LOR

arithOpFirst ::= STAR | SLASH | MODULO | HAT | STARSTAR //TODO what is it ? Do we keep it in newOz ?

arithOpSecond ::= PLUS | MINUS

arithOpThird ::= EQUAL | NE | LT | LE | GT | GE

//label ::= UNIT | TRUE | FALSE | variable | atom //TODO actually not used anywhere

feature ::= UNIT | TRUE | FALSE | atom | int | NIL //TODO not implemented like this

classDescription ::= EXTENDS variableStrict {COMMA variableStrict}+
                    | ATTR variable [ASSIGN expression]
                    | PROP variable

//attrInit ::= ([LNOT] variable | atom | UNIT | TRUE | FALSE) [COLON expression] //TODO not implemented

methHead ::= ([LNOT] variableStrict | atomLisp | UNIT | TRUE | FALSE) //TODO not implemented like this
              [LPAREN methArg {COMMA methArg} [COMMA ELLIPSIS] [DOLLAR] RPAREN]

methArg ::= [feature COLON] (variable | UNDERSCORE) [LE expression]

variableStrict ::= UPPERCASE {ALPHANUM}
              | LACCENT {VARIABLECHAR | PSEUDOCHAR} LACCENT

variable ::= LOWERCASE {ALPHANUM}
          | APOSTROPHE {VARIABLECHAR | PSEUDOCHAR} APOSTROPHE //TODO really ?

atom ::= atomLisp
        | RACCENT {ATOMCHAR | PSEUDOCHAR} RACCENT

atomLisp ::= APOSTROPHE (LOWERCASE | UPPERCASE) {ALPHANUM}

string ::= QUOTE {STRINGCHAR | PSEUDOCHAR} QUOTE

character ::= CHARINT
            | DEGREE CHARCHAR
            | DEGREE PSEUDOCHAR
            | CHAR // TODO in this case we should send a warning during analysis that it is not supported in underlying oldOz

int ::= [MINUS] DIGIT
        | [MINUS] NONZERODIGIT {DIGIT}
        | [MINUS] "0" {OCTDIGIT}+
        | [MINUS] ("0x"|"0X") {HEXDIGIT}+
        | [MINUS] ("0b"|"0B") {BINDIGIT}+

float ::= [MINUS] {DIGIT}+ DOT {DIGIT} [("e" | "E")[~]{DIGIT}+]

boolean ::= TRUE | FALSE